\chapter{Metodika}

V této kapitole popíšeme některé detaily implementací binárních vyhledávacích stromů, které vznikly pro potřeby této práce (ne však rozhraní těchto implementací -- to popíšeme později v příloze práce). Dále popíšeme metodiku měření času a počtu dotčených vrcholů.

\section{Implementace}

Všechny testované struktury jsme implementovali v jazyce C. Ten byl zvolen
proto, že umožňuje kontrolovat, co přesně měříme -- měření nám nepokazí ani
interní fungování interpreteru, jako by hrozilo, kdybychom zvolili například
Python, ani zásahy garbage collectoru, které by se nám nevyhnuly například v
Javě.

Při implementaci testovaných struktur jsme pro každou strukturu
naimplementovali operaci \ope{Find}. Dále jsme pro červenočerný strom a splay
strom napsali operaci \ope{Insert}, pro zbylé dva stromy potom operaci
\ope{Build}. Protože ale stavbu struktury nechceme měřit, tak před měřením pro
červenočerný a splay strom struktury nejprve vybudujeme tím, že do nich
postupně vložíme všechny klíče, které mají obsahovat, v rostoucím pořadí (tento postup jsme obzvláště u červenočerného stomu zvolili záměrně, abychom dostali na začátku pokud možno co nejhůře vyvážený červenočerný strom). 

Od reálného použití (přinejmenším červenočerného a splay stromu) jsme se mírně odchýlili metodou alokace paměti na nové vrcholy -- abychom dosáhli co nejpředvídatelnějšího chování, alokujeme jedno pole vrcholů se začátkem zarovnaným na stránku paměti a vrcholy budeme mít uložené v něm. Adresy nových vrcholů v rámci tohoto pole jsme nejprve přiřazovali sekvenčně, ale po zjištěních ze sekce \ref{sec:rb_and_cache} jsme počínaje měřeními popsanými v sekci \ref{sec:sequential_access_sequence} přiřazovali pro červenočerný strom adresy v náhodném pořadí. 

Dále jsme se odchýlili od modelu -- ve snaze minimalizovat množství paměti zabírané jednotlivými vrcholy jsme se rozhodli nemít ve vrcholech ukazatele na rodiče a místo toho si ukazatele na rodiče všech vrcholů mezi aktuálním vrcholem a kořenem držet na zásobníku. Čistě pro zjednodušení algoritmu jsem se také rozhodli operace \ope{Split} a \ope{Join} červenočerného stromu, které jsou interně využívány operací \ope{Find} tango stromu, neimplementovat pomocí rotací hran, ale přímo tak jak byly popsány v sekci o červenočerném stromu. 

\citet{tango} ve svém článku o tango stromu také mluví o tom, že jako součást přístupu vždy změní preferovaný směr v cílovém vrcholu na směr doleva. Protože však tato změna není pro důkazy složitosti tango stromu nutná, rozhodli jsme se jí nedělat (naopak změna preferovaného směru v cílovém vrcholu multisplay stromu nutná je, tu tedy provádíme).

Všechny ostatní implementační problémy řešíme přímočaře přesně podle popisu v první kapitole této práce a příslušných článků.

\section{Měření}

Měření počtu dotčených vrcholů jsme provedli tak, že jsme každé operaci \ope{Find}
přiřadili její pořadové číslo. V každém vrcholu jsme si zaznamenali pořadové číslo
operace, při které byl naposled navštíven. Poté jsme vždy, když jsme se dotkli daného
vrcholu, kde dotykem myslíme dereferencování na něj mířícího ukazatele,
zkontrolovali, zda jsme ho během této operace již viděli, a pokud ne, změnili jsme
číslo poslední operace které máme v tomto vrcholu zaznamenané a zvýšili
počítadlo dotčených vrcholů o jedna.

Měření času jsme provedli pomocí jiného programu, než kterým počítáme doteky
(experimentálně jsme totiž zjistili, že samo počítání doteků násobně zpomaluje
běh). Stejně jako v případě počtu doteků používáme naši implementaci datových
struktur, jejíž zdrojový kód je součástí elektronických příloh práce. K její
kompilaci jsme použili překladač {\tt gcc} ve verzi {\tt 10.2.1} s úrovní
optimalizací {\tt O3}. Při měření času jsme postupovali tak, že pro syntetické
testy jsme přesměrovali standardní výstup generátoru (jehož zdrojový kód je
taktéž součástí elektronických příloh práce) na standardní vstup testovaného
programu, pro praktický test jsme na standardní vstup testovaného programu
přesměrovali soubor s daty. V testovacím programu poté nejprve vybudujeme
strukturu patřičné velikosti, potom načteme ze standardního vstupu do pole
prvních nejvýše $1\cdot10^7$ prvků přístupové posloupnosti. Potom začneme měřit
čas a vykonáme načtenou část přístupové posloupnosti. Pokud ještě zbývá
nenačtená část posloupnosti, měření přerušíme, načteme dalších nejvýše
$1\cdot10^7$ prvků a změříme tuto část posloupnosti. Takto pokračujeme, dokud
se nedostaneme na konec posloupnosti.

Procesorový čas jsme měřili pomocí funkce {\tt clock()} z hlavičkového souboru
{\tt time.h}. K měření jsme použili procesor {\tt AMD EPYC 7301} s
frekvencí  $2.7\, \operatorname{GHz}$. Tento procesor obsahuje 8 fyzických a tedy
16 logických jader, naše měření však nebylo nijak paralelizováno. V systému bylo
k dispozici $126\,\operatorname{GB}$ RAM. Vzhledem k tomu, že na pamětově
nejnáročnější z navržených testů stačilo méně než $10\,\operatorname{GB}$
paměti, nás tedy dostupná paměť nijak neomezila. Měření proběhlo pod operačním
systémem {\tt Debian GNU/Linux 11}.

