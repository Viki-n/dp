\chapter{Metodika}

V~této kapitole popíšeme některé detaily implementací binárních vyhledávacích stromů, které vznikly pro potřeby této práce (ne však jejich rozhraní -- to popíšeme později v~příloze práce). Dále popíšeme metodiku měření času a počtu dotčených vrcholů.

\section{Implementace}

Všechny testované struktury jsme implementovali v~jazyce C. Ten byl zvolen
proto, že umožňuje kontrolovat, co přesně měříme. Měření nám nepokazí ani
interní fungování interpreteru, což by hrozilo, kdybychom zvolili například
Python, ani zásahy garbage collectoru, kterým bychom se nevyhnuli například
v~Javě.

Při implementaci testovaných struktur jsme pro každou strukturu
naimplementovali operaci \ope{Find}. Dále jsme pro červenočerný strom a splay
strom napsali operaci \ope{Insert}, pro zbylé dva stromy potom operaci
\ope{Build}. Protože ale stavbu struktury nechceme měřit,  vybudujeme před měřením
červenočerný a splay strom struktury nejprve tím, že do z počátku prázdné struktury
postupně vložíme všechny klíče, které mají obsahovat, v~rostoucím pořadí. Tento postup jsme obzvláště u~červenočerného stromu zvolili záměrně, abychom dostali na začátku pokud možno co nejhůře vyvážený červenočerný strom.

Od reálného použití (přinejmenším červenočerného a splay stromu) jsme se mírně
odchýlili metodou alokace paměti na nové vrcholy -- abychom dosáhli co
nejpředvídatelnějšího chování, alokujeme jedno pole vrcholů se začátkem
zarovnaným na stránku paměti a vrcholy budeme mít uložené v~něm. Adresy nových
vrcholů v~rámci tohoto pole jsme nejprve přiřazovali sekvenčně, ale po
zjištěních ze sekce \ref{sec:rb_and_cache} jsme, počínaje měřeními popsanými
v~sekci \ref{sec:sequential_access_sequence}, přiřazovali pro červenočerný strom
adresy v~náhodném pořadí. 

Dále jsme se odchýlili od modelu -- ve snaze minimalizovat množství paměti
zabírané jednotlivými vrcholy jsme se rozhodli neukládat ve vrcholech ukazatele na
rodiče a místo toho si ukazatele na rodiče všech vrcholů mezi aktuálním
vrcholem a kořenem držet na zásobníku. Čistě pro zjednodušení algoritmu jsme se
také rozhodli operace \ope{Split} a \ope{Join} červenočerného stromu, které
jsou interně využívány operací \ope{Find} tango stromu, neimplementovat pomocí
rotací hran, ale přímo tak, jak byly popsány v~sekci o~červenočerném stromu. 

\citet{tango} ve svém článku o~tango stromu mluví mimo jiné o~tom, že jako
součást přístupu vždy změní preferovaný směr v~cílovém vrcholu na směr doleva.
Protože však tato změna není pro důkazy složitosti tango stromu nutná, rozhodli
jsme se ji neprovádět (naopak změna preferovaného směru v~cílovém vrcholu
multisplay stromu nutná je, tu tedy provádíme).

Všechny ostatní implementační problémy řešíme přímočaře přesně podle popisu
v~první kapitole této práce a v příslušných článcích.

\section{Měření}

Měření počtu dotčených vrcholů jsme provedli tak, že jsme každé operaci \ope{Find}
přiřadili její pořadové číslo. V~každém vrcholu jsme si zaznamenali pořadové číslo
operace, při které byl naposled navštíven. Poté jsme vždy, když jsme se dotkli daného
vrcholu (dotekem vrcholu myslíme dereferencování na něj mířícího ukazatele),
zkontrolovali, zda jsme ho během této operace již viděli. Pokud ne, změnili jsme
číslo poslední operace, které máme v~tomto vrcholu zaznamenané, a zvýšili
počítadlo dotčených vrcholů o~jedna.

Měření času jsme provedli pomocí jiného programu, než kterým počítáme doteky
(experimentálně jsme totiž zjistili, že samo počítání doteků násobně zpomaluje
běh). Stejně jako v~případě počtu doteků používáme naši implementaci datových
struktur, jejíž zdrojový kód je součástí elektronických příloh práce. K~její
kompilaci jsme použili překladač {\tt gcc} ve verzi {\tt 10.2.1} s~úrovní
optimalizací {\tt O3}. Při měření času jsme postupovali tak, že jsme rourou propojili standardní výstup generátoru (jehož zdrojový kód je
taktéž součástí elektronických příloh práce) a standardní vstup testovaného
programu. V~testovacím programu poté nejprve vybudujeme
strukturu patřičné velikosti, potom načteme ze standardního vstupu do pole
prvních nejvýše $10^7$ prvků přístupové posloupnosti. Pak začneme měřit
čas a vykonáme načtenou část přístupové posloupnosti. Pokud ještě zbývá
nenačtená část posloupnosti, měření přerušíme, načteme dalších nejvýše
$10^7$ prvků a změříme tuto část posloupnosti. Takto pokračujeme, dokud
se nedostaneme na konec posloupnosti.

Procesorový čas jsme měřili pomocí funkce {\tt clock()} z~hlavičkového souboru
{\tt time.h}. K~měření jsme použili procesor {\tt AMD EPYC 7301}
s~frekvencí  $2.7\, \operatorname{GHz}$. Tento procesor obsahuje 16 fyzických, a tedy
32 logických jader, naše měření však nebylo nijak paralelizováno. Jedno jádro má k dispozici $64\,\operatorname{kB}$ L1 cache, $512\,\operatorname{kB}$ L2 cache a $8\,\operatorname{MB}$ L3 cache. Procesory však mohou využívat i L3 cache patřící jiným procesorům; součet kapacit všech L3 cachí v systému je $128\,\operatorname{MB}$. V~systému bylo
k~dispozici $126\,\operatorname{GB}$ RAM. Vzhledem k~tomu, že na paměťově
nejnáročnější z~navržených testů stačilo méně než $10\,\operatorname{GB}$
paměti, nás tedy dostupná paměť nijak neomezila. Měření proběhlo pod operačním
systémem {\tt Debian GNU/Linux 11}.

Měření času jsme systematicky neopakovali, ale na základě několika pokusů jsme dospěli k závěru, že rozptyl mezi více měřeními téže přístupové posloupnosti je zanedbatelný.
