\def\maybetext{\ifmmode\noexpand\hbox\fi}
\def\ope#1{\maybetext{{\sc#1}}}

\chapter{Teoretický úvod}

V této kapitole zavedeme formální definici binárního vyhledávacího stromu a
pojednáme o jeho výhodách oproti jiným způsobům uložení dat. Dále přiblížíme
(staticky) optimální strom. Pro dynamické stromy připomeneme některé běžné
vyvažovací strategie a také představíme jiné, novější přístupy, například třídu
rankově vyvážených stromů a jejich speciální případ Weak AVL strom. Potom
představíme několik mezí optimality, vlastností, které musí mít optimální
binární vyhledávací strom. Nakonec se podíváme na Tango stromy a Multisplay
stromy a dokážeme, že tyto meze splňují (nebo, v případě tango stromu, že je
téměř splňují).

\section{Binární vyhledávací strom}
\def\U{\mathcal U}
\def\o{\mathcal O}
\let\op\operatorname

Častým úkolem datové struktury je udržovat informaci o množině prvků. Formálně
mějme univerzum $\mathcal U$, lineární uspořádání na tomto univerzu $\leq$, a
konečnou podmnožinu tohoto univerza $M$. Budeme chtít vybudovat datovou strukturu, která bude umět o
každém prvku $\mathcal U$ říct, jestli náleží množině $M$. Po takových
strukturách často chceme nějaké z následujících operací:

\begin{itemize}
\item $\ope{Find}(x)$: pro prvek $x \in \U$ rozhodnout, zda $x\in M$,
\item $\ope{Insert}(x)$: přidat prvek $x \in \U$ do množiny $M$,
\item $\ope{Delete}(x)$: odstranit prvek $x\in M$ z $M$,
\item $\ope{Enumerate}()$: vyjmenovat všechny prvky $M$,
\item $\ope{Succ}(x)$, resp $\op{Pred}(x)$: pro daný prvek $x\in \U $ najít nejbližší (ostře) větší, resp. menší prvek $M$,
\item $\ope{RangeQuery}(x,y)$: pro dané dva prvky $x,y\in\U$ takové, že $x<y$, spočítat nebo vyjmenovat všechny prvky $z\in M$ takové, že $x \leq z \leq y$.
\end{itemize}

Volba struktury v každém konkrétním případě závisí na tom, které z těchto
operací potřebujeme v naší konkrétní aplikaci podporovat. Pokud nám například
stačí umět prvky vyjmenovat, postačí nám obyčejné pole. Pokud chceme umět
vyhledávat, přidávat i mazat v průměru v konstantním čase, je nejlepší volbou nějaká
varianta hashovací tabulky. Zejména poslední tři zmíněné operace ale hashovací
tabulka umí pouze v čase $\Theta(|M|)$. Pokud tedy tento typ dotazů potřebujeme
struktuře pokládat, můžeme využít nějakou ze stromových datových struktur,
které v této práci popíšeme.

\begin{definice}
Mějme datovou strukturu, která se skládá z vrcholů. Každý vrchol může mít až
dva následníky, kterým budeme říkat \emph{levý} a \emph{pravý syn}. Jeden
vrchol nazveme \emph{kořen}. Všechny ostatní vrcholy pak budou mít právě
jednoho \emph{rodiče} (tak, že pokud vrchol $u$ je rodičem vrcholu $v$, pak
vrchol $v$ je pravým nebo levý synem vrcholu $u$)\footnote{V některých
implementacích si vrcholy nemusí pamatovat ukazatele na své rodiče, my budeme
však prozatím předpokládat, že si je pamatují.}. Pro vrchol $v$ nazveme
\emph{podstrom vrcholu $v$} množinu vrcholů, do nichž se dá dostat z z vrcholu
$v$ libovolnou\footnote{Posloupnost může být i prázdná.} posloupností kroků 
\uv{přejdi do pravého syna} a \uv{přejdi do levého syna}.

V každém vrcholu bude pak právě jedna hodnota, a navíc bude pro každý vrchol $v$ platit, že hodnoty ve všech vrcholech v podstromu levého syna $v$ jsou ostře menší než hodnota ve $v$, a hodnoty v podstromu pravého syna naopak ostře větší.

Nakonec si zapamatujeme ukazatel na kořen tak, abychom ho kdykoli v konstantním čase nalezli.

Této datové struktuře budeme říkat \emph{binární vyhledávací strom}
\end{definice}

Při práci se stromem budeme předpokládat, že následující kroky umíme v konstantním čase:
\begin{itemize}
\item Nalezni kořen,
\item přejdi do pravého, případně levého syna aktuálního vrcholu,
\item přejdi do rodiče aktuálního vrcholu,
\item přečti či zapiš hodnotu v aktuálním vrcholu,
\item pokud aktuální vrchol nemá pravého či levého syna, vytvoř na jeho místě nový vrchol s danou hodnotou.
\end{itemize}
Vyhledávání hodnoty $x$ ve stromu pak můžeme provést podle následujícího algoritmu:
\begin{enumerate}
\item Nalezni kořen.
\item Podívej se, zda je hodnota $x$ rovna hodnotě v aktuálním vrcholu, a pokud ano, nahlaš nález.
\item Je-li hodnota $x$ větší než hodnota v aktuálním vrcholu, podívej se, zda existuje pravý syn aktuálního vrcholu. Pokud ano, přejdi do něj a vrať se ke 2. kroku algoritmu, jinak ohlaš, že  $x$ ve stromu není.
\item Je-li hodnota $x$ menší než hodnota v aktuálním vrcholu, podívej se, zda existuje levý syn aktuálního vrcholu. Pokud ano, přejdi do něj a vrať se ke 2. kroku algoritmu, jinak ohlaš, že  $x$ ve stromu není.
\end{enumerate}

Podobným algoritmem budeme prvky přidávat, pouze místo nahlášení neexistence na místě chybějícího syna založíme nový vrchol. Mazání prvku provedeme následovně:

\begin{itemize}
\item Je-li vrchol obsahující mazaný prvek list, prostě ho smažeme.
\item Má-li vrchol obsahující mazaný prvek právě jednoho syna, prvek smažeme a jeho syna připojíme pod rodiče mazaného prvku na místo mazaného prvku.
\item Má-li vrchol obsahující mazaný prvek dva syny, najdeme ve stromě prvek nejblíže větší, jeho
hodnotu zapíšeme na místo odstraňovaného prvku a odstraníme vrchol, v němž byl tento nejblíže větší
prvek, kterému nutně chybí přinejmenším levý syn (kdyby existoval, hodnota v
něm by byla menší než hodnota jeho rodiče, ale větší než hodnota odstraňovaného
vrcholu -- tedy jeho rodič by nemohl být nejbližší větší).  
\end{itemize} 

\section{Statická optimalita}\label{sec:staticoptimality}

Podívejme se na životní cyklus binárního vyhledávacího stromu. Takový strom
nejprve vybudujeme s (ne nutně neprázdnou) počáteční množinou klíčů
a potom na na něm vykonáme nějakou posloupnost operací. My se prozatím omezíme
pouze na případ, kdy strom vybudujeme nad neprázdnou množinou klíčů, a jediná
operace, kterou budeme vykonávat, bude operace vyhledání. Navíc budeme
požadovat, aby všechny klíče, které ve stromě hledáme, skutečně ve stromě byly.
Potom je posloupnost operací jednoznačně dána pouze hodnotami, na které se
dotazujeme (a jejich pořadím; hodnoty nemusí být různé). Posloupnost těchto
hodnot budeme nazývat \emph{přístupová posloupnost}, budeme ji značit $S$ a
její délku budeme značit $m$.

Přirozená otázka zní, jak vypadá binární vyhledávací strom, který pro danou
posloupnost přístupů vykoná nejméně operací. V plné obecnosti budeme tuto otázku řešit v pozdějších částech této kapitoly. Pro tuto sekci se omezíme na statické
stromy. To znamená stromy, které vybudujeme nad předem danou množinou klíčů, a
za běhu už nebudeme podporovat vkládání a mazání, ani neumožníme měnit
strukturu stromu. Na druhou stranu budeme předpokládat, že přístupovou posloupnost, nebo alespoň četnost jednotlivých prvků v ní, předem známe. V tomto modelu se počet operací přesně rovná
počtu navštívených vrcholů (včetně násobnosti).

Problém konstrukce optimálního stromu v tomto modelu vyřešil dynamickým
programováním \citet{staticoptimality}. Myšlenku jeho algoritmu zde představíme.

Mějme množinu klíčů, pro jednoduchost $[n]$\footnote{Tímto značení myslíme
množinu přirozených čísel od 1 do $n$ včetně.} a pole vah $w$. Váha vrcholu
$i$ $w[i]$ může být buď pravděpodobnost, že daný přístup bude mít za
cíl naleznout vrchol $i$, nebo počet výskytů $i$ v přístupové
posloupnosti. V prvním případě dostaneme jako váhu výsledného stromu střední
hodnotu počtu navštívených vrcholů při přístupu, v druhém případě součet počtu navštívených vrcholů přes
celou přístupovou posloupnost.

Algoritmus je založený na myšlence, že podstrom libovolného vrcholu v
optimálním stromu je sám o sobě optimální strom nad příslušnými prvky. Proto
stačí pro všechny možné volby kořene rekurzivně spočítat optimální strom pro
prvky menší než kořen a větší než kořen, a z takto spočítaných stromů vybrat
ten s nejmenší váhou. Protože přímočará implementace tohoto postupu by běžela v
exponenciálním čase, budeme si váhy (a případně kořeny) dílčích optimálních
stromů ukládat. Již tato myšlenka stačí k tomu, abychom optimální strom postavili
v čase $\Theta(n^3)$. Algoritmus lze však upravit tak, aby měl kvadratickou časovou složitost.



\section{Vyvažované stromy}

Co když však potřebujeme umět do struktury i vkládat? Můžeme pokračovat naivně
podle algoritmu uvedeného výše v této kapitole. \citet{sortingsearching}
ukázal, že pokud budeme prvky do stromu vkládat v náhodném pořadí\footnote{Bez
újmy na obecnosti předpokládáme, že do struktury postupně vložíme všechny prvky
z množiny $[n]$ pro vhodně zvolené $n$. Potom náhodné pořadí znamená pořadí
určené rovnoměrně náhodně zvolenou permutací z množiny $S_n$}, s vysokou
pravděpodobností dostaneme strom, v němž bude průměrná hloubka vrcholu $2 \ln n$.
\citet{Robson} dále ukázal, že pokud $H(n)$ střední hodnota hloubky nejhlubšího 
vrcholu ve stromě o $n$ vrcholech, pak $$\lim_{m\rightarrow
\infty}\frac{H(n)}{\ln(n)}\leq\alpha,$$ kde $\alpha$ je přibližně
$4.311\dots$, přesně se jedná o největší kořen rovnice $$\alpha\cdot \ln
\frac{2e}{\alpha} = 1.$$ \citet{devroye} později dokázal, že výše uvedená
nerovnost je ve skutečnosti rovnost.

V praxi však často klíče potřebujeme vkládat i v pořadí, které není náhodné,
ale obsahuje nějaký vzorec. Například pokud bychom do (na počátku prázdného)
nevyvažovaného binárního stromu vložili čísla z množiny $[n]$ vzestupně, strom
zdegeneruje v jednu jedinou cestu, na níž bude nejhlubší vrchol v hloubce $n$ a
průměrná hloubka vrcholu bude $(n+1)/2$. Takovýmto případům bychom se rádi
vyhnuli, proto prozkoumáme vyvažované stromy. Protože však všechny stromy,
které budeme zkoumat, budou vyvažované pomocí rotací hran, nejprve představíme,
co taková rotace hrany je, a to jak obrázkem \ref{obr:rotace}, tak formální definicí.


\begin{figure}[h!]
\begin{tabular}{cc}

\begin{subfigure}{0.45\textwidth}
  \centering
  \includegraphics[width=.99\linewidth]{../img/single_rotation}
\end{subfigure}&

\begin{subfigure}{0.45\textwidth}
  \centering
  \includegraphics[width=.99\linewidth]{../img/zigzig_rotation}
\end{subfigure}\\

\noalign{\bigskip}
(a) Jednoduchá rotace hrany $xy$. 
&
(b) Zig-zig rotace.\\
\noalign{\bigskip}

\multicolumn{2}{c}{
\begin{subfigure}{0.9\textwidth}
  \centering
  \includegraphics[width=.65\linewidth]{../img/zigzag_rotation}
\end{subfigure}}\\
\noalign{\bigskip}
\multicolumn{2}{c}{
  (c) Zig-zag rotace. Tato rotace jako jediná není symetrická.
}
\end{tabular} 
\caption{Jednoduchá, zig-zag a zig-zig rotace.} 

\label{obr:rotace} 
 
\end{figure}

\begin{definice}
Mějme vrchol binárního vyhledávacího stromu $u$ a jeho (bez újmy na obecnosti levého) syna $v$. Dále si
označíme $p$ rodiče vrcholu $u$, $A$ a $B$ popořadě levý a pravý podstrom $v$ a
$C$ pravý podstrom $u$. Pak \emph{(jednoduchá) rotace hrany $uv$} je krok,
při níž nastavíme vrchol $v$ jako syna $p$ (na stejné straně, kde byl původně
vrchol $u$), vrchol $u$ jako pravého syna $v$ a podstrom $B$ jako levý podstrom
$u$. Podstromy $A$ a $C$ zůstanou připojené k vrcholům $v$ a $u$ tak, jak byly.

Dále mějme vrchol $u$, jeho (bez újmy na obecnosti levého) syna $v$ a syna
vrcholu $v$, kterého si označíme $w$. Potom pokud $w$ je pravý syn, můžeme
provést \emph{dvojitou rotaci hran $wv$ a $vu$ typu zig-zag}, která probíhá tak,
že nejprve zrotujeme hranu $wv$, a potom hranu $vu$. Pokud je $w$ levý syn,
můžeme provést \emph{dvojitou rotaci hran $wv$ a $vu$ typu zig-zig}, která
probíhá tak, že nejprve zrotujeme hranu $vu$ a potom hranu $wv$.
\end{definice}

Rotace hrany se může zdát jako zvláštní operace. Téměř všechny vyvažovací algoritmy (a úplně všechny, o kterých zde budeme mluvit) ale využívají k vyvažování právě rotace, protože se jedná o poměrně jednoduchou a překvapivě silnou operaci, která zachovává uspořádání.

Dvojité rotace typu zigzig budeme potřebovat později v této kapitole. V této
sekci si vystačíme s jednoduchými rotacemi a dvojitými rotacemi typu zig-zag,
proto budeme-li mluvit o dvojitých rotacích, budeme tím mít na mysli právě typ
zigzag.

\subsection{AVL stromy}

AVL strom poprvé představili \citet{AVL}. Jedná se o typ vyvažovaného stromu. V
AVL stromu platí, že hloubka pravého a levého podstromu\footnote{Pravým, resp. levým podstromem vrcholu myslíme podstrom pravého, resp. levého syna tohoto vrcholu} každého vrcholu se liší
nejvýše o jedna. To znamená, že pokud $D(n)$ označíme minimální počet vrcholů
ve stromu hloubky $n$, dostáváme, že $D(0)=0$, $D(1)=1$ a
$D(i)=1+D(i-1)+D(i-2)$ pro každé $i$ větší než jedna. Pokud vyřešíme tuto
rekurenci, zjistíme, že $D(i)=\log_\varphi(i) + \o(1)$, kde $\varphi = 1.618\dots$ je zlatý
řez.

V každém vrcholu si budeme pamatovat navíc informaci o vyvážení tohoto vrcholu.
Tato informace může nabývat tří možných hodnot -- daný vrchol může být buď
\emph{vyvážený} (oba jeho podstromy jsou stejně hluboké), nebo \emph{nakloněný
doprava}, (jeho pravý podstrom je o jedna hlubší než levý), nebo
\emph{nakloněný doleva}\footnote{Vystačili bychom si i s jediným bitem, který by udával, zda je podstrom daného vrcholu hlubší než podstrom jeho souseda.}.


\begin{figure}[h!]

\begin{subfigure}{0.9\textwidth}
  \centering
  \includegraphics[width=.65\linewidth]{../img/single_rotation_avl}
\end{subfigure}
\vskip 1cm
\begin{subfigure}{0.9\textwidth}
  \centering
  \includegraphics[width=.65\linewidth]{../img/zigzag_rotation_avl}
\end{subfigure}
\caption{Použití jednoduché a zig-zag rotace k vyvážení AVL stromu.} 

\label{obr:rotace_avl} 
 
\end{figure}



Vyhledání prvku probíhá stejně, jako v nevyvažovaném binárním vyhledávacím stromě. 
Vkládání je ale trochu komplikovanější. Při připojení nového listu je potřeba
jeho rodiči změnit vyvážení. Byl-li vyvážený (tj. byl to list), nově bude
nakloněný za novým vrcholem. Byl-li nakloněný od nového vrcholu, bude nově
vyvážený. V prvním případě navíc vzrostla celková hloubka podstromu tohoto
vrcholu, je tedy potřeba změnu vyvážení propagovat výše do stromu. Kromě
předchozích dvou případů  může při další propagaci nastat ještě jeden jiný,
totiž že byl vrchol už původně nakloněný směrem ze kterého propagujeme. To
znamená, že po přidání nového vrcholu již neplatí invariant AVL stromu a musíme
provést buď jednoduchou nebo dvojitou rotaci hrany, abychom situaci napravili.

Nechť $x$ je nejhlubší vrchol ve stromu, který nesplňuje AVL invariant. Hloubku jeho podstromu před vložením posledního vrcholu si označíme $k$. Nechť byl bez újmy na obecnosti vložen vrchol do podstromu jeho pravého syna $y$. Pak je nutné rozebrat následující případy:
\begin{itemize}
\item Nový vrchol byl vložen do pravého podstromu vrcholu $y$ (první případ na obrázku \ref{obr:rotace_avl}). Potom lze jednoznačně dopočítat hloubky ostatních relevantních vrcholů (na obrázku pod podstromy, vždy počítáno vůči vrcholu $x$) na základě toho, že víme, že vrchol $x$ musí porušovat AVL invariant, ostatní vrcholy ho musí splňovat, před vložením nového vrcholu musely AVL invariant splňovat všechny vrcholy a hloubka podstromu $x$ musela být $k$. Pak můžeme AVL invariant opravit jednoduchou rotací.
\item Nový vrchol byl vložen do levého podstromu $y$. Potom musíme provést
dvojitou rotaci. Jednu z možností hloubek jednotlivých podstromů v takovém případě zobrazuje
druhý případ naobrázku \ref{obr:rotace_avl}. Další možnost, kterou však není potřeba v kódu
rozlišovat a vyřešíme ji úplně stejně, spočívá v prohození hloubek podstromů
$B$ a $C$ z obrázku.  
\end{itemize}

Provedením rotace však zařídíme, že se celý podstrom rotovaného vrcholu o jedna
sníží. To znamená, že bude mít stejnou výšku jako před \ope{Insert}em a změnu tedy
není potřeba dále propagovat. Přirozená otázka může být, když vyvažováním vždy zajistíme, že se hloubka stromu nezmění, jak je možné, že do něj můžeme postupně vložit libovolně mnoho vrcholů? To je tím, že celková hloubka stromu se může změnit právě při takových \ope{Insert}ech, které nezpůsobí žádnou rotaci hrany.

Operaci \ope{Delete} zde podobně detailně probírat nebudeme, podotkneme ale, že na rozdíl od operace \ope{Insert} může být nutné až řádově logaritmicky mnoho rotací vůči vůči počtu vrcholů ve stromě (tj. lineárně mnoho vůči hloubce stromu). Kdybychom strom nejprve postavili posloupností operací \ope{Insert} a poté vymazali všechny vrcholy posloupností operací \ope{Delete}, mohli bychom ukázat, že provedeme amortizovaně konstantně mnoho rotací na operaci. Pokud však operace \ope{Insert} a \ope{Delete} dostatečně nevhodně proložíme, může se stát, že budeme potřebovat až logaritmicky mnoho rotací na operaci.



\subsection{Červenočerný strom}\label{sec:RB}

Červenočerný strom odvodili z 2-4 stromů \citet{redblack}. Pro popis
červenočerného stromu se nám bude hodit alternativní pohled na binární stromy.
Představíme si, že na každé míso ve stromě, kde nějakému vrcholu chybí pravý nebo levý syn, přidáme jeden list.
Tím dostaneme strom, v němž bude každý vrchol mít buď právě dva, nebo
žádného potomka. Vrcholy, které nemají žádného potomka, neobsahují žádný klíč
ani jiná data. V programu tedy mohou být reprezentovány například nulovými
ukazateli. Těmto vrcholům budeme říkat \emph{vnější} nebo také \emph{externí}
vrcholy. Rozmyslíme si, že externích vrcholů je ve stromě s $n$ neexterními vrcholy $n+1$, a každý z nich odpovídá jednomu intervalu mezi dvěma po sobě jdoucími hodnotami ve stromu (nebo intervalu mezi jednou z krajních hodnota  plus nebo mínus nekonečnem).

Nyní již máme veškerou terminologii potřebnou k tomu, abychom mohli přistoupit k definici. Červenočerný strom je vyvažovaný binární strom, který dále splňuje následující invarianty:

\begin{enumerate}
\item Každý vrchol má buď červenou, nebo černou barvu.
\item Všechny externí vrcholy považujeme za černé.
\item Na každé cestě z kořene do externího vrcholu musí být stejný počet černých vrcholů.
\item Každý červený vrchol má oba potomky černé.
\end{enumerate}

Některé zdroje dále uvádí, že kořen musí být černý, to však není problém kdykoli zařídit -- máme-li korektní červenočerný strom s červeným kořenem, můžeme kořen přebarvit na černo a všechny invarianty zůstanou splněny. Pokud však budeme černou barvu kořene požadovat, bude ve stromě lépe vidět souvislost s původními 2-4 stromy. V takovém případě si můžeme všimnout, že pokud zkontrahujeme všechny hrany mezi červeným synem černého otce, dostaneme strom, ve kterém má každý vrchol kromě listů mezi dvěma a čtyřmi potomky, a ve kterém jsou všechny cesty z kořene do listu stejně dlouhé.

Nyní se pokusíme odhadnout minimální počet vrcholů $D(n)$ ve stromu hloubky $n$. Strom s minimálním počtem vrcholů při dané hloubce vypadá tak, že obsahuje jednu cestu, na níž se střídají červené a černé vrcholy, a na každý její vrchol dále pověsíme dokonale vyvážený strom tvořený pouze černými vrcholy o hloubce určené tak, aby byly splněny invarianty. To znamená, že jeden z podstromů kořene je strom s minimálním počtem vrcholů při hloubce o jedna menší, a druhý je dokonale vyvážený strom. Kdybychom se pokusili $D(n)$ vyjádřit pouze pomocí $D(n-1)$, muselo by se nám ve vzorci objevit zaokrouhlování ve formě dolní celé části. Abychom se zaokrouhlování vyhnuli, vyjádříme $D(n)$ pomocí $D(n-2)$.

$D(n)$ můžeme vyjádřit\footnote{V následujícím výpočtu nebereme v úvahu externí vrcholy. Kdybychom je v úvahu brali, přesné vzorce by vypadaly trochu jinak, ale v závěru by se změna schovala v $\o$-notaci.} jako $D(1)=1$, $D(2) = 2$, $D(2i) = D(2i-2) + 2 \cdot
(2^{i - 1} - 1) + 2$, $D(2i + 1) = D(2i - 1) + 2^{i-1}-1 + 2^i-1 + 2$. Z toho
po zjednodušení a vyřešení dostáváme, že $D(i)\in\Theta(2^{i/2})$, tedy nejvyšší
možná hloubka s daným počtem vrcholů je $H(n) = \log_{\sqrt 2} n + \o(1)$.
Protože  $\sqrt 2 < \varphi$, je hloubka červenočerného stromu v nejhorším
případě větší než hloubka AVL stromu v nejhorším případě při stejném počtu
vrcholů.

Průběh operací \ope{Insert} a \ope{Delete} zde nebudeme probírat, protože obsahují velké
množství speciálních případů, které by bylo potřeba popsat. Připojíme ale
dvě poznámky. První z nich je, že výhodou červenočerných stromů oproti AVL
stromům je vždy pouze konstantně mnoho změn struktury stromu při operaci. Druhá
věc, kterou je zde vhodné zmínit, je velice příbuzná struktura, tzv.
\emph{right-leaning červenočerný strom}, který představil \citet{rightleaning}.
V tomto stromu navíc platí, že pokud má vrchol právě jednoho červeného syna,
musí to být pravý syn. Tím sice může mírně vzrůst celkový počet rotací k
vyvážení struktury, ale výrazně se sníží počet případů, které je třeba při
vyvažování řešit a strom se tak stane implementačně výrazně jednodušší. V této
práci dále pokračoval \citet{leftleaning}, který dále zakázal vrcholy, jejichž
oba synové by byli červení. V této úpravě pak lze naimplementovat operaci
\ope{Insert} na pouhých 33 řádcích kódu v jazyce Java.    

Červenočerné stromy ale dále umí dvě operace, které zde představíme, protože
jich využívají datové struktury, které představíme později v této práci. Bude se jednat o operace \emph{\ope{Join}} a \emph{\ope{Split}}.
Před jejich popisem budeme ale potřebovat zavést ještě dva nové pojmy.

\begin{definice}
Mějme červenočerný strom $S$. Pak počet černých vrcholů na cestě mezi kořenem a (libovolným) externím vrcholem $S$ (nepočítaje koncové vrcholy této cesty) nazveme \emph{černou výškou} stromu $S$. Značit ji budeme $H'(S)$.
\end{definice}


\begin{definice}
Mějme libovolný neprázdný binární vyhledávací strom $S$ a jeho vrchol $u$, resp. $v$, odpovídající minimálnímu, resp. maximálnímu prvku v něm. Pak cestu z kořene do $u$, resp. $v$ nazveme \emph{levou}, resp. \emph{pravou páteří} stromu $S$.
\end{definice}

Operace \ope{Join} má na vstupu dva červenočerné
stromy $A$, $B$ a jeden další prvek univerza $x$. Pro tyto stromy musí platit,
že hodnoty všech prvků ve stromu $A$ jsou menší než $x$ a hodnoty všech prvků
ve stromu $B$ jsou větší než $x$. Na výstupu operace \ope{Join} máme jeden strom
obsahující všechny prvky, které obsahoval strom $A$, strom $B$, a prvek $x$. Za
předpokladu, že předem známe černou výšku stromů $A$
a $B$ $H'(A)$ a $H'(B)$, operaci \ope{Join} zvládneme v čase $\Theta(1+|H'(A) -
H'(B)|)$.

Při provádění operace \ope{Join} budeme postupovat následovně:

\begin{enumerate}
\item Pokud $H'(A) = H'(B)$, pak můžeme vytvořit nový černý vrchol s hodnotou $x$, jako jeho levého a pravého syna nastavit kořeny stromů $A$ a $B$ a vrátit ho jako kořen nového stromu.
\item Jinak bez újmy na obecnosti předpokládejme, že $H'(A)<H'(B)$. Potom můžeme jít po pravé páteři stromu $A$, dokud nenalezneme vrchol $v$ takový, že černá výška jeho podstromu je $H'(B)$. Vytvoříme nový červený vrchol $u$ s hodnotou $x$ a vložíme ho do stromu na místo vrcholu $v$. Vrchol $v$ připojíme pod $u$ jako levého syna a kořen stromu $B$ jako pravého syna. Mohlo se stát, že jsme právě rozbili invariant červenočerného stromu. Jeho platnost tedy obnovíme podobným postupem jako při normálním \ope{Insert}u.
\end{enumerate}

Druhá operace je operace \ope{Split}. Operace \ope{Split} dostane na vstupu strom\footnote{Z popisu operace \ope{Split} vyplyne, že není specifická pro červenočerné stromy. Tuto operaci můžeme provést pro libovolný typ binárního vyhledávacího stromu, který podporuje operace \ope{Delete} a \ope{Join}. Pouze analýza časové složitosti bude specifická pro červenočerné stromy.} $S$ a $x\in \mathcal U$. Na výstupu má dva stromy $A$, $B$ takové, že všechny prvky ve stromu $A$ budou menší než $x$, a prvky ve stromu $B$ jsou větší než $x$. Stromy $A$ a $B$ navíc obsahují dohromady ty samé prvky, jako strom $S$ (kromě prvku $x$, pokud tento prvek byl ve stromě $S$). Operaci \ope{Split} zvládneme na červenočerném stromu v čase $\o(\log n)$. Postup bude následující:

\begin{enumerate}

\item Vyhledáme ve stromě $S$ prvek $x$. Pokud si v naší implementaci
červenočerného stromu nepamatujeme u každého vrcholu černou výšku jeho
podstromu, při cestě dolů budeme tyto černé výšky počítat. To můžeme udělat
například tak, že si ke každému vrcholu poznamenáme, kolik je černých vrcholů
na cestě mezi ním a kořenem (kořen včetně, vrchol sám nevčetně). Poté spočítáme
černou výšku celého stromu (pokud $x$ ve stromě není, stačí spočítat počet
černých vrcholů na cestě mezi kořenem a externím vrcholem, na jehož místo
bychom $x$ vkládali. Jinak pokračujeme stromem dolů až k libovolnému externímu
listu). Černá výška podstromů jednotlivých vrcholů je pak rozdíl mezi číslem,
které jsme si k nim poznamenali, a černou výškou původního
stromu\footnote{Černou výšku celého stromu ve skutečnosti ani počítat nemusíme.
Pro \ope{Join} ve skutečnosti nepotřebujeme znát černé výšky, stačí nám pouze umět v
konstantním čase určit rozdíl černých výšek dvou stromů, což lze již ze
zapamatovaných čísel.}.

\item Na cestě, kterou jsme při vyhledání prošli, odstraníme všechny hrany.
Vrcholy si roztřídíme do dvou seznamů podle toho, zda jsou větší nebo menší než
$x$. V seznamech udržujeme pořadí, v jakém jsme vrcholy na cestě našli --
seznamy jsou setříděné podle černých výšek podstromů, které zůstaly viset na
vrcholech. Pokud $x$ byl ve stromu, odstraníme ho a na konec našich seznamů
připojíme vždy příslušného syna $x$.

\item Nyní tedy máme dva seznamy vrcholů, kde na každém z těchto vrcholů visí
právě jeden syn. Podstrom tohoto syna je vždy validní červenočerný strom, a
navíc známe jeho černou výšku. Výjimkou může být vždy poslední vrchol v seznamu
-- ten může mít oba syny, ve kterémžto případě již on sám je kořen korektního
červenočerného stromu. Navíc platí, že oba seznamy jsou setříděny podle černých výšek stromů (tyto černé výšky nemusí být po dvou různé). Dále platí, že v seznamu prvků větších než $x$ je vždy hodnota vrcholu menší, než hodnota všech prvků v jeho zbývajícím (pravém) podstromu, ale větší, než hodnota všech prvků (a jejich zbývajících podstromů), které jsou v seznamu dále než oni (protože se původně jednalo o části jejich levého podstromu). Nyní tedy pro každý seznam zvlášť:

\item Pokud poslední prvek seznamu není kořen korektního červenočerného stromu, udělej z něj korektní červenočerný strom. To znamená, že vezmeme červenočerný strom, který visí na prvku seznamu, a prvek, na kterém původně visel, do něj vložíme standardní operací \ope{Insert}.

\item Všechny prvky seznamu spojíme operací \ope{Join}. Budeme postupovat od konce, a to vždy tak, že vezmeme poslední prvek seznamu, což je validní červenočerný strom, syna předposledního prvku, což je také červenočerný strom, a předposlední prvek seznamu sám (či přesněji jeho hodnotu), což je prvek univerza hodnotou mezi dvěma zmíněnými stromy, a aplikujeme na tyto dva stromy a tento prvek operaci \ope{Join}. Výsledný strom opět připojíme na konec seznamu. 

\end{enumerate}

Úvodní nalezení $x$ zvládneme v čase $\o(\log n)$. Při slučování využijeme toho, že stromy byly původně seřazeny podle černé výšky a spojování tuto výšku změnilo nejvýše o konstantu (uvědomíme si, že vždy nejvýše dva po sobě jdoucí stromy mohly mít původně stejnou černou výšku, černé výšky tedy nemohou růst příliš), tedy součet všech rozdílů černých výšek spojovaných stromů je nejvýše výška původního stromu plus jejich počet krát konstanta. Oba sčítance jsou nejvýše $\o(\log n)$, celá operace \ope{Split} tedy proběhne v čase $\o(\log n)$.

\subsection{Rankově vyvažované stromy}

\citet{rankbalanced} vyšli z myšlenek \citet{dichromatic}, kteří zobecnili
myšlenku červenočerných stromů, a představili nový způsob uvažování o
vyvažovaných stromech. Každému vrcholu přiřadili celočíselný rank, přičemž
externí vrcholy mají rank $-1$ a rank ostatních vrcholů je nezáporný. Různým
nastavením pravidel pro rozdíly ranků mezi vrcholem a jeho syny potom dostali
různé datové struktury. Abychom však o těchto strukturách mohli snadno mluvit,
musíme nejprve zavést několik pojmů.

\begin{definice}
Řekneme, že vrchol binárního vyhledávacího stromu je \emph{$a$-syn}, pokud rozdíl jeho ranku a ranku jeho rodiče je právě $a$. O vrcholu řekneme, že je \emph{$(a,b)$-vrcholem}, pokud jeho potomci jsou (ne nutně v tomto pořadí) $a$-syn a $b$-syn.
\end{definice}

Všimneme si, že pokud si jako pravidlo zvolíme, že každý vrchol bude $(1,1)$
nebo $(1,2)$-vrchol, bude rank každého vrcholu roven právě délce nejdelší cesty
(počítané počtem hran) z něj do listu v jeho podstromu, a výsledný strom bude
AVL strom\footnote{Všimneme si, že v tomto myšlenkovém rámci dává smysl, aby si každý vrchol pamatoval, zda je $1$-synem či $2$-synem. Pak dostáváme přesně AVL strom s jediným bitem vyvažovací informace na vrchol, který jsme popsali v poznámce pod čarou výše.}. Pokud si jako pravidlo zvolíme, že každý vrchol kromě kořene je
$1$-syn nebo $0$-syn a žádný $0$-syn není synem $0$-syna, dostaneme
červenočerný strom, v němž $1$-synové odpovídají černým vrcholům (požadavek na
nezápornost ranků vrcholů zajišťuje, že všechny externí vrcholy jsou
$1$-synové).

Existuje ale ještě jiné pravidlo, kterým dostaneme červenočerné stromy. Pokud povolíme $1$-syny a $2$-syny, dostáváme také červenočerné stromy. Nyní ovšem černým vrcholům odpovídají nejen $2$-synové, ale i $1$-synové s lichým rankem. Takový strom určitě invariant červenočerného stromu splňuje -- máme-li dva vrcholy spojené hranou se sudým rankem, je (minimálně) spodní z nich 2-syn. Naopak pokud mám libovolný červenočerný strom, můžu každému vrcholu $v$, jehož podstrom si označím $S$, přiřadit rank $2\cdot H'(S)$, pokud je $v$ červený a $2\cdot H'(S) + 1$ pokud je černý.

Toto pravidlo lze také formulovat tak, že každý vrchol je buď $(1,1)$, $(1,2)$ nebo $(2,2)$-vrchol. Toto pravidlo vypadá podobně jako AVL pravidlo. Mohli bychom se tedy ptát, zda neexistuje nějaké pravidlo, které by bylo restriktivnější než pravidlo červenočerných stromů, ale volnější než pravidlo AVL stromů, které by nám umožnilo spojit výhody obou těchto stromů. Připomeneme, že výhodou AVL stromu je o něco menší hloubka nejhlubšího vrcholu v nejhorším případě, výhodou červenočerných stromů je garance nejvýše $\o(1)$ změn struktury na operaci. 

Toho skutečně lze dosáhnout, a to pomocí následujících dvou pravidel:
\begin{enumerate}
\item Všechny listy (tj. vrcholy, jejichž oba synové jsou externí) jsou $(1,1)$-vrcholy.
\item Všechny ostatní vrcholy jsou buď $(1,1)$, $(1,2)$ nebo $(2,2)$-vrcholy.
\end{enumerate}

S touto sadou pravidel navíc s (přímočarými) \ope{Insert} a \ope{Delete} algoritmy, které \citet{rankbalanced} popsali, dostáváme \emph{Weak AVL} strom, který má následující vlastnosti:

\begin{itemize}
\item Při \ope{Insert}ech nevznikají $(2,2)$-vrcholy -- pokud pouze vkládáme, máme AVL strom.
\item Pouze $\o(1)$ změn struktury stromu na operaci v nejhorším případě.
\item Pouze $\o(1)$ změn ranku na operaci amortizovaně. Navíc počet změn ranku vrcholu ranku $k$ je amortizovaně $\o(\varphi^{-k})$ na operaci.
\item Pokud $n$ je počet vrcholů stromu a $m$ je počet operací \ope{Insert} za celou dobu života struktury, pak hloubka stromu je nejvýše $\min(\log_{\varphi} m, \log_{\sqrt2} n) + \o(1).$ Z toho vyplývá, že pokud $m\in\Theta(n)$, tj. ve stromu máme alespoň řádově stejně prvků. kolik jsme jich smazali, bude hloubka Weak AVL stromu v nejhorším případě až na aditivní konstantu stejná, jako hloubka AVL stromu v nejhorším případě na stejném počtu prvků.
\item Weak AVL strom lze rebalancovat nejen odspoda nahoru, ale i preventivně shora dolů, což může být výhodné při paralelní práci se stromem. Pak ale ostatní zde uvedené body neplatí.
\end{itemize}



\section{Výpočetní model}
Chceme-li mluvit o optimálním stromu, musíme nejprve specifikovat, co přesně
budeme za binární vyhledávací strom považovat. Pro zjednodušení se opět vrátíme
ke stromům nad pevnou množinou klíčů. Nebudeme tedy podporovat operace \ope{Insert} a \ope{Delete}\footnote{Budeme předpokládat, že strom již stavíme nad neprázdnou množinou klíčů.}.
Definici, kterou zde
představíme, používali implicitně už \citet{splay}, formalizoval ji však až
\citet{tango}.


\begin{definice}
Mějme \emph{přístupovou posloupnost} $S$ $x_1$,$x_2$,\dots,$x_m$, kde $\forall i \in
\mathbb N, i\leq m$ platí $x_i\in M$. Pak \emph{přístupový algoritmus
binárního vyhledávacího stromu} je algoritmus, který postupně provede přístupy
ke vrcholům s klíči $x_1, x_2,\dots,x_m$.

Přístup probíhá tak, že algoritmus smí mít vždy právě jeden ukazatel na vrchol
stromu, který na počátku každého přístupu ukazuje na kořen stromu. Dále v
každém kroku smí provést právě jeden z kroků tak, jak byly popsány v úvodu této kapitoly, případně rotaci hrany mezi aktuálním vrcholem a jeho rodičem. 

Řekneme, že čas běhu algoritmu je počet těchto kroků, které za sekvenci
přístupů provede, plus jedna\footnote{Čas strávený výpočtem toho, jaký krok se má provést, zanedbáme.}. O vrcholu stromu řekneme, že jsme se ho při daném
přístupu \emph{dotkli}, pokud na něj někdy během tohoto přístupu ukazoval
ukazatel algoritmu.  \end{definice}

Takovému přístupovému algoritmu se někdy také říká \emph{offline přístupový
algoritmus}. V praxi ale potřebujeme přístupy provádět online.

\begin{definice}
\emph{Online přístupový algoritmus} je takový přístupový algoritmus, jehož
rozhodnutí během $i$-tého přístupu nijak neovlivňují hodnoty $x_j$ z přístupové
posloupnosti pro $j>i$. Na druhou stranu si tento algoritmus smí v každém
vrcholu uložit až $\mathcal O(1)$ slov paměti informací (nikoli však ukazatele
na vrcholy).
\end{definice}

Všimneme si, že běžné algoritmy binárních vyhledávacích stromů tuto definici
splňují -- Například červenočerné a AVL stromy potřebují v každém vrcholu
jediný bit informace, splay strom se obejde zcela bez dalších informací.

Pro danou přístupovou sekvenci $S$ existuje přístupový algoritmus, který ji
vykoná optimálně, tedy v nejkratším čase ze všech možných algoritmů. Tento
počet kroků označíme $\opt(S)$. Zde předpokládáme, že je strom na začátku v
nejlepší možné konfiguraci. Tím však nesnížíme potřebný čas na přístupy o více
než aditivní $\mathcal O(n)$, protože z libovolného BVS je možné pomocí
$\mathcal O(n)$ rotací vytvořit libovolný jiný (nad tou samou množinou klíčů).
Proto budeme dále zkoumat pouze přístupové posloupnosti $S$ takové, že $m \in
\Omega(n)$. Vzhledem k tomu, že nahlédneme, že $\opt(S)\geq m$, je aditivní
faktor $\o(n)$ asymptoticky zanedbatelný. 


\begin{definice}
O přístupovém algoritmu řekneme, že je \emph{$f(n)$-kompetitivní}, pokud každou
posloupnost přístupů $X$ nad univerzem velikosti $n$ vykoná v čase $
\o(f(n))\cdot\opt(X)$. O online přístupovém algoritmu řekneme, že je
\emph{dynamicky optimální}, pokud je $\mathcal O(1)$-kompetitivní.
\end{definice}

Předtím, než si popíšeme některé konkrétní stromy, už pouze podotkneme, že
existence dynamicky optimálního algoritmu je otevřeným problémem. Na druhou
stranu například o splay stromech vyslovili \citet{splay} hypotézu, že jsou
dynamicky optimální.

\section{Splay stromy}

Splay strom představili \citet{splay}. Jedná se o strom, který modifikuje svou strukturu nejen při operacích \ope{Insert} a \ope{Delete}, ale i při vyhledávání\footnote{Přestože splay strom vkládání i mazání podporuje, my se nyní zabýváme modelem, kde stromy umí pouze vyhledávat. Proto budeme předpokládat, že operaci \ope{Delete} nikdy nevykonáme, a všechny operace \ope{Insert} vykonáme před začátkem měření v rámci inicializace struktury.}. Splay strom podporuje operaci $\ope{Splay}(x)$, a všechny ostatní stromové operace implementuje pomocí $\o(1)$ volání této operace.

Samotná operace $\ope{Splay}(x)$ se sestává ze dvou fází: Nejprve standardním způsobe
vyhledáme vrchol stromu obsahující klíč $x$, a poté tento vrchol pomocí rotací
hran přesuneme do kořene. V případě neúspěšného hledání přesuneme do kořene poslední navštívený vrchol. Při přesouvání vrcholu do kořene postupujeme tak, že
pokud je vzdálenost aktuálního vrcholu od kořene stromu alespoň dva, použijeme
vždy dvojitou rotaci (v závislosti na tom, zda jsou splayovaný vrchol a jeho
rodič synové na téže či různé straně použijeme buď zig-zig rotaci, nebo zig-zag
rotaci). Pouze ve chvíli, kdy je splayovaný vrchol synem kořene, použijeme
jednoduchou rotaci. Tento postup má za následek, že hloubka splayovaného vrcholu se sníží na nulu, hloubka všech ostatních vrcholů, kterých se během splayování dotkneme, se sníží přinejmenším o polovinu (až na aditivní konstantu) a hloubka vrcholů, kterých jsme se nedotkli, se zvýší maximálně o konstantu.

Pomocí operace $\ope{Splay}(x)$ naimplementujeme ostatní stromové operace. Při operaci \ope{Insert}(x) nejprve zavoláme $\ope{Splay}(x)$. Tím se dostane následník nebo předchůdce $x$ do kořene. Potom můžeme vložit nový vrchol obsahující $x$ mezi jeho pravého nebo levého syna. Při operaci \ope{Delete} na prvek zavoláme $\ope{Splay}$, poté ze stromu odstraníme kořen a dva vzniklé stromy (jsou-li oba neprázdné)  spojíme dále popsanou operací \ope{Join}. Operaci \ope{Join} tak, jak byla popsána v kapitole \nameref{sec:RB}, můžeme provést tak, že ve stromu, který bez újmy na obecnosti obsahuje menší prvky ze dvou spojovaných stromů, zavoláme $\ope{Splay}(\infty)$. Tím dostaneme nejvyšší prvek do kořene. Kořeni proto bude chybět pravý syn. Na jeho místo tedy můžeme připojit druhý strom. Pokud máme v rámci spojování prvek mezi hodnotami obou stromů do stromu vložit, stačí ho prohlásit za nový kořen a jako syny mu připojit kořeny původních stromů. \ope{Split} provedeme následovně:

\begin{enumerate}
\item $\ope{Split}(x)$ v našem případě rozdělí strom na stromy s hodnotou klíče větší než $x$, menší než $x$, a případně nechá samostatně vrchol s hodnotou $x$, pokud ve stromě byl. Začneme tedy zavoláním $\ope{Splay}(x)$.
\item Pokud byl vrchol s klíčem $x$ nalezen, máme hotovo -- vrátíme samostatně kořen stromu a jeho jednotlivé podstromy jako výstup.
\item Jinak bez újmy na obecnosti nechť máme v kořeni vrchol s klíčem větším než $x$. Jedná se ale o nejblíže větší, proto můžeme odpojit jeho levého syna a oba takto vzniklé stromy vrátit jako výstup.
\end{enumerate}

Splay strom nám garantuje logaritmickou amortizovanou složitost operace $\ope{Splay}$. V některých situacích může však být i lineárně hluboký. Pokud například přistoupíme ke všem prvkům v rostoucím pořadí, bude mít strom tvar cesty, kde každý vrchol (krom jediného listu) bude mít pouze levého syna. Pokud poté zavoláme $\ope{Splay}$ na nejmenší prvek ve stromě, bude trvat lineárně dlouho, avšak hloubku stromu zmenší o polovinu.

Jak už jsme napsali výše, o splay stromu byla vyslovena hypotéza, že je dynamicky optimální, avšak pro obecnou přístupovou posloupnost pro něj nebylo dokázáno nic silnějšího, než triviální $\log(n)$-kompetitivita. Pro některé konkrétní přístupové sekvence byly však pro splay strom dokázány zajímavé výsledky, které si představíme v další kapitole.

\section{Meze optimality}

Výše uvedená definice optimality bohužel není příliš užitečná, protože není
znám algoritmus, který by efektivně spočítal chování optimálního binárního
vyhledávacího stromu. Proto různí autoři přišli s různými odhady na $\opt(S)$.
My zde předvedeme několik horních odhadů a jeden dolní odhad. Začneme třemi
odhady, které představili \citet{splay}. Ti ve svém článku rovnou ukázali, že
všechny tři meze (až na aditivní člen závisející pouze na $n$) splay strom
splňuje. Proto musí platit i pro optimální strom. Proč můžeme pro optimální
stromy aditivní členy závisející pouze na $n$ vypustit, vysvětlíme později v této sekci.

\begin{veta}[Static Optimality Bound]
Mějme přístupovou posloupnost $S$ délky $m$ nad množinou $[n]$, a nechť $q:[n]\rightarrow \mathbb N_0$ určuje počet výskytů každého prvku $[n]$ v $S$. Potom $$\opt(S) \in \o\left(m + \sum_{i\in [n]}q(i)\log\frac m{q(i)}\right).$$
\end{veta}

Tuto mezi splňuje i statický optimální strom popsaný v sekci \nameref{sec:staticoptimality}. Proto také všem stromům, které tuto mezi splňují, říkáme staticky optimální.  

\begin{veta}[Static Finger Bound]
Mějme přístupovou posloupnost $S$ délky $m$ nad množinou $[n]$ jejíž $i$-tý prvek si označíme $s_i$. Potom pro libovolné $f\in [m]$ platí $$\opt(S) \in \o\left(m + \sum_{i\in [m]} \log(1 + |f-s_i|) \right).$$
\end{veta}

Tato meze jinými slovy říká, že strom musí umět rychle odpovídat na dotazy na
prvky blízko libovolného fixního prvku. Tuto mez původně představili v silnější
verzi \citet{fingersearchtree} ve článku o \emph{prstovém vyhledávacím stromu}. To je
struktura, která umožňuje udržovat nějaké množství \emph{prstů}, z nichž každý
ukazuje na nějaký vrchol. Tato struktura umožňuje přidávat a odstraňovat prsty
v čase $\o(\log n)$. Vyhledání pak trvá $\o(f+\log(d))$, kde $f$ je počet prstů
a $d$ je počet prvků mezi vyhledávaným prvkem a nejbližším prstem.
\citet{splay} však nicméně ukázali, že tato mez platí pro jeden nepohyblivý
prst (až na jednorázovou aditivní konstantu nezávisející na počtu přístupů) i
pro splay stromy. Jak se splay strom chová, když se rozhodneme prst přesouvat,
představíme později v této sekci. 


\begin{veta}[Working Set Bound]

Mějme přístupovou posloupnost $S$ délky $m$ nad množinou $[n]$ jejíž $i$-tý prvek si označíme $s_i$. Dále mějme funkci $t: [m]\rightarrow \mathbb N_0$, kde $t(i)$ je počet různých prvků v posloupnosti $S$ mezi $i$-tým prvkem a předchozím výskytem prvku $s_i$ (nebo od začátku, pokud se jedná o první výskyt prvku $s_i$). Potom platí $$\opt(S) \in \o\left(m + \sum_{i\in [m]}\log (t(i)+1) \right).$$
\end{veta}

Jinými slovy, pokud pracujeme pouze s malou podmnožinou prvků ve stromě, amortizovaná cena přístupů musí být logaritmická pouze ve velikosti této podmnožiny.

\begin{veta}[Dynamic Finger Bound]
Mějme přístupovou posloupnost $S$ délky $m$ nad množinou $[n]$ jejíž $i$-tý prvek si označíme $s_i$. Potom pro platí $$\opt(S) \in \o\left(m + \sum_{i=2}^m \log(1 + |s_{i}-s_{i-1}|) \right).$$
\end{veta}

Tato mez nám umožňuje prst v každém kroku přesunout na právě navštívený prvek. Pro splay stromy ji dokázal \citet{dynamicfinger}.

Před posledními dvěma mezemi uděláme slibovanou odbočku. Na tu se nám ale bude 
hodit mové značení.

\begin{definice}
Mějme posloupnost $S$ o $m$ prvcích a posloupnost $T$ o $t$ prvcích. Pak \emph{zřetězením} posloupností $S$ a $T$ budeme rozumět posloupnost $S\|T$ o $m+t$ prvcích takovou, že $\forall i\leq m: (S\|T)_i = S_i$ a $\forall i, m<i<m+t: (S\|T)_i = T_{i-m}$. Dále zrcadlením posloupnosti $S$ bude posloupnost $\overline{S}$ délky $m$ taková, že $\forall i\leq m$ platí $S_i = \overline{S}_{m-i+1}$. 
\end{definice}

U všech předchozích
vět v této kapitole jsme postupovali tak, že jsme vzali tvrzení, že splay strom
dovede libovolnou přístupovou posloupnost $S$ vykonat v čase $\o(f(n)+g(S))$
pro vhodné funkce $f$ a $g$, a z toho jsme vyvodili, že optimální strom tu
samou posloupnost vykoná v čase $\o(g(S))$. Toto tvrzení teď dokážeme. Dokážeme
ho sice pro libovolnou funkci $f$, ale pouze pro funkce $g$, které jsou nejvýše
lineární vzhledem k zřetězení. Jinými slovy, budeme požadovat, aby pro každé dvě přístupové posloupnosti $S$, $T$ $g(S) + g(T)\geq
g(S\|T)$.
\begin{tvrz}\label{tvrz:konstantypryc}
Mějme libovolnou funkci $f:\mathbb N \rightarrow \mathbb N$ a funkci $g$ z množiny všech konečných posloupností přirozených čísel do $\mathbb N$ 
takovou, že pro každé dvě posloupnosti $S$, $T$ platí $g(S\|T)\leq g(S)+g(T)$. Dále nechť splay strom (nebo jakýkoli jiný
konkrétní strom) umí vykonat libovolnou posloupnost o délce alespoň $n$ pomocí nejvýše
$f(n) + g(S)$ kroků. Pak optimální strom umí tu samou posloupnost vykonat pomocí nejvýše $g(S)$ kroků.
\end{tvrz}

\begin{dukaz}
Mějme nějakou pevnou posloupnost $S$. Dále mějme posloupnost $S'$, která je
posloupnost $S$ $(f(n)+1)$-krát zřetězená sama za sebe. Tu umí splay strom
vykonat v čase nejvýše $$f(n) + g(S') \geq f(n) + (f(n)+1) \cdot g(S).$$ Tato
nerovnost platí z podmínek na funkci $g$ popsaných v minulém odstavci. Nyní
tedy víme, že splay strom vykoná posloupnost $S'$ v čase nejvýše
$f(n)+(f(n)+1)\cdot g(S))$. Vykonání posloupnosti $S'$ je ale pouze $f(n)$ po
sobě jdoucích vykonání posloupnosti $S$. Během vykonávání $S'$ tedy vykonáme
$S$ v průměru v čase nejvýše $$\frac{f(n)}{f(n)+1}+g(S).$$ To znamená, že
alespoň jedno z vykonání $S$ trvalo nejvýše právě tento průměr.
Kroků algoritmu musí být celočíselný počet, $g(S)$ je celé číslo a zlomek ve výrazu
výše je menší než jedna. Proto muselo nejkratší vykonání $S$ trvat nejvýše $g(S)$.
Optimální strom si ale při svém běhu může vybrat svůj počáteční stav. Může si
tedy rozhodně vybrat počáteční stav takový, v jakém byl splay strom na začátku
vykonávání tohoto nalezeného nejkratšího vykonání $S$, a dále se chovat jako
splay strom.
\end{dukaz}

Toto tvrzení můžeme přímočaře aplikovat na Static Optimality Bound a Static
Finger Bound. Dynamic Finger Bound bohužel nesplňuje předpoklad věty, jednoduše
ale nahlédneme, že pro $m\geq n$ nebude relaxování příslušné funkce $g$
přidáním aditivního $\log(1+|s_{m} - s_{1}|)$ asymptoticky zajímavé a poté již
můžeme tvrzení aplikovat. Working Set Bound ale tak jednoduše nevyřešíme,
budeme potřebovat ještě jedno zdánlivě nesouvisející lemma:

\begin{lemma}
Mějme přístupovou posloupnost $S$. Pak $\opt(\overline S) \in \Theta(\opt(S))$, a to i v případě, že budeme požadovat, aby optimální strom při vykonávání posloupnosti $\overline{S}$ začal se stromem ve stejném stavu, v jakém byl optimální strom na konci vykonávání $S$, a na konci vykonávání $\overline S$ ve stejném stavu, v jakém optimální strom při vykonávání $S$ začal.
\end{lemma}

\begin{dukaz}
Nahlédneme, že nám stačí ukázat, že pokud máme binární vyhledávací strom $T$ a
algoritmus $A$, který ho při vyhledání hodnoty $x$ převede ze stavu $T_1$ do stavu
$T_2$ během $k$ kroků, pak existuje i algoritmus $B$, který při vyhledání hodnoty
$x$ převede strom ze stavu $T_2$ do stavu $T_1$ pomocí $\o(k)$ kroků.

To ale platí -- Všechny kroky, které algoritmus $A$ udělá, může algoritmus $B$
udělat v opačném pořadí a opačným směrem. Jediný problém nastane, pokud
algoritmus $A$ využije krok \uv{najdi kořen}, a stejný problém nastane na
začátku běhu algoritmu $B$, kdy je nutné vrátit se na místo ve stromě, kde byl
aktuální vrchol algoritmu $A$ před voláním tohoto kroku, případně před koncem.
Rozmyslíme si ale, že to dokážeme v tolika krocích, jak hluboko příslušný
vrchol je, a minimálně tolik kroků musel algoritmus $A$ udělat, aby se předtím
do této hloubky dostal. Tato hledání tedy zpomalí běh algoritmu $B$ nejvýše
dvojnásobně. Protože při tomto postupu sáhneme na všechny vrcholy, na které
sáhl algoritmus $A$, tak pokud algoritmus $A$ nalezl vrchol $x$, nalezl ho
algoritmus $B$ také\footnote{Neúspěšná hledání nebudeme brát v potaz}.
\end{dukaz}

Nyní už si pouze rozmyslíme, že důkaz pro Working Set Bound můžeme vést
podobně, jako pro tvrzení \ref{tvrz:konstantypryc}, ale místo posloupnosti $S$ za sebe
$(f(n)+1)$-krát zřetězit posloupnost $S\|\overline S$. Tím bychom měli odbočku
úspěšně za sebou a můžeme se vrátit k odhadům. 

\begin{veta}[Preorder Access Bound]
Mějme libovolný binární vyhledávací strom $T$ nad množinou klíčů $[n]$. Mějme posloupnost $S$ délky $n$, která prochází strom $T$ v preorder pořadí. To znamená že první prvek $S$ je kořen $T$, poté následují prvky levého podstromu kořene v preorder pořadí a nakonec prvky pravého podstromu kořene v preorder pořadí. Pak $$\opt(S)\in \o(n).$$
\end{veta}

Pro porozumění větě je nutné si uvědomit, že strom $T$ použijeme pouze k
generování přístupové posloupnosti -- se stromem, který používá optimální nebo
jakýkoli jiný vyhledávací algoritmus, obecně nemusí mít nic společného. Preorder
Access Bound není v plné obecnosti pro splay stromy dokázána.
\citet{preordertarjan} tuto mez představil a pro splay stromy dokázal její
speciální případ, kde strom $T$ je celý roven své pravé páteři. Tomu odpovídá
$S$, která obsahuje všechny prvky $[n]$ v rostoucím pořadí.
\citet{preordersplay} ukázali, že splay strom dokáže v lineárním čase provést
posloupnost přístupů odpovídající preorder pořadí jeho vlastního stavu před prvním
přístupem. Z toho vyplývá, že Preorder Access Bound skutečně pro dynamicky
optimální strom platí -- může se nejprve v lineárním čase rotacemi přestavět na strom,
kterému odpovídá konkrétní přístupová sekvence, a dále se chovat jako splay
strom. 

Nyní se podíváme na jediný dolní odhad, který nás v této kapitole čeká, a ze kterého budeme vycházet v následujících kapitolách.

\def\ib{\operatorname{IB}}

\begin{veta}[Interleave Bound]
Mějme přístupovou posloupnost $S$ nad množinou $[n]$. Dále mějme libovolný
(statický) strom $T$ nad toutéž množinou klíčů. Každý vrchol $T$ má svůj
preferovaný směr. Vždy, když projdeme vrcholem $v$, nastavíme preferovaný směr
$v$ na syna, do nějž jsme z vrcholu $v$ pokračovali. $\ib_T(S)$ označíme
celkový počet změn preferovaných směrů\footnote{Protože nás zajímají pouze
posloupnosti $S$ takové, že jejich délka $m$ je větší nebo rovna $n$, počáteční
nastavení preferovaných směrů ovlivní $\ib_T(S)$ nejvýše o multiplikativní
konstantu.} ve stromě $T$ při vykonání posloupnosti přístupů $S$. Pak pro
libovolný strom $T$ platí $$\opt(S) \in \Omega(\ib_T(S)).$$ 
\end{veta}

Interleave bound představili a dokázali v tomto znění \citet{tango}. Podobný odhad (lišící se pouze multiplikativní konstantou) ale představil už \citet{interleave}.

Tato mez nám dává mimo jiné rodinu konkrétních posloupností $S$ takových, že
$\opt(S)\in\Theta(m\log n)$: Pokud jako strom $T$ zvolíme dokonale vyvážený
binární strom, můžeme přistupovat k prvkům v jeho listech v takovém pořadí,
abychom vždy v každém procházeném vrcholu změnili preferovaný směr.

Pokud je množina klíčů ve vrcholech stromu $[2^k-1]$ pro nějaké $k$, dostaneme
tímto postupem stejnou posloupnost, jako kdybychom vzali hodnoty v listech a
seřadili jejich binární zápisy nejprve podle cifry s váhou $2^0$, potom $2^1$
potom $2^2$ a tak dále. Jinými slovy jako bychom binární zápisy klíčů (doplněné
zleva nulami aby měly sstejnou délku) nejprve zrcadlili, a poté seřadili
standardně. Proto se této posloupnosti říká \emph{bit reversal posloupnost}.

Na druhou stranu však ukážeme, že pro žádný pevný strom $T$ není Interleave Bound těsná:
\begin{tvrz}
Pro každý strom strom $T$ na $n$ vrcholech a pro každé přirozené číslo $m>n$ existuje posloupnost $S$ délky $m$ taková, že $\ib_T(S) \in \o(m)$, ale $\opt(S) \in \Theta(m\cdot\log\log n).$ 
\end{tvrz}

\begin{dukaz}
Mějme tedy strom $T$. Nechť $P$ je nejdelší cesta z kořene do listu v $T$. Poté
mějme strom $T'$ na stejných vrcholech jako $T$, který vznikne tak, že nejprve
postavíme dokonale vyvážený strom nad vrcholy $P$, a poté do něj vložíme zbylé
vrcholy z $T$ v libovolném pořadí standardním algoritmem binárního
vyhledávacího stromu. Nyní nad vrcholy z $P$ uplatníme myšlenku bit reversal
posloupnosti. Tím dostaneme posloupnost $S$ požadované délky, v níž jsou pouze
vrcholy z $P$. $P$ byla nejdelší cesta v $T$, tedy $|P|\in \Omega(\log n)$.
Proto $\opt(S)\geq \ib_{T'}(S) \in \Omega (\log\log n)$, ale protože v $T$ jsou
všechny vrcholy z $S$ na jedné cestě, tak $\ib_T(S) \in \o(n) \subseteq \o(m)$.
\end{dukaz}

Na druhou stranu například pro dokonale vyvážený strom $T$ pro každou posloupnost $S$ platí $$\opt(S) \in \Omega(\ib_T(S))\, \cap\, \o(\ib_T(S)\cdot\log\log n).$$ Této složitosti totiž v dosahuje v následující kapitole popsaný tango strom.
Zda pro každou posloupnost $S$ existuje
strom $T$ takový, že $\opt(S)\in\o(\ib_T(S))$, není známo.  

\section{Tango stromy}\label{sec:tango}

\citet{tango} představili Tango strom. Tango strom je (spolu s výše uvedeným
splay stromem a v následující kapitole popsaným multisplay stromem) jedna z
hlavních struktur, které budeme chtít v dalších kapitolách této práce zkoumat,
proto ho popíšeme detailněji.

Tango strom je strom, který podporuje pouze operaci vyhledání. Udržuje si
pomyslný statický dokonale vyvážený\footnote{Algoritmu ve skutečnosti stačí,
aby měl referenční strom logaritmickou hloubku.} referenční binární vyhledávací
strom $P$ nad těmi samými klíči, které sám obsahuje. Každou přístupovou
posloupnost pak vykoná v čase $\o(\log\log n\cdot \ib_P(S))$, tedy je
$(\log\log n)$-kompetitivní. Na druhou stranu není optimální -- z konstrukce
bude zřejmé, že pokud budeme přistupovat stále k témuž prvku, dostaneme posloupnost, kterou optimální strom
 vykoná v čase $\o(m)$, ale tango strom může potřebovat až
$\Theta(m\cdot\log\log n )$. Co hůře, bit reversal posloupnost tango strom vykoná v čase $\Theta(m\cdot\log(n)\cdot \log\log(n))$.

Této časové složitosti dosáhne tak, že si bude vnitřně udržovat rozdělení na
\emph{pomocné podstromy}, které odpovídají cestám z preferovaných hran daných
preferovanými směry v $P$ tak, jak byly nadefinovány ve znění Interleave Bound.
Těm budeme říkat \emph{preferované cesty}. Tyto pomocné stromy budou červenočerné stromy. Protože všechny cesty v $P$
jsou nejvýše logaritmicky dlouhé, bude každá operace (ať už \ope{Find}, nebo \ope{Split}
či \ope{Join}) s pomocnými stromy trvat $\o(\log\log n)$ času. Pomocných stromů
navštívíme (včetně násobnosti) za celé vykonávání přístupové posloupnosti právě
$\ib_P(S)$.

Každý vrchol musí obsahovat následující informace:
\begin{itemize}
\item Svou barvu v pomocném červenočerném stromě
\item Zda je kořenem pomocného stromu
\item Svou hloubku v $P$
\item Maximum a minimum hloubek v $P$ všech vrcholů v jejich podstromu. Podstromem vrcholu zde však budeme rozumět pouze podstrom v rámci pomocného stromu, ve kterém se příslušný vrchol nachází.
\end{itemize}

Při vyhledání budeme potřebovat umět ve stromu $P$ změnit preferovaný směr vrcholu $v$. Tomu odpovídá potřeba odstranit z příslušného pomocného stromu vrcholy na preferované cestě v $P$, které na ní leží pod $v$, a naopak připojení preferované cesty začínající v synovi $v$, k němuž nově vede preferovaná hrana. K popisu této operace ale budeme potřebovat následující lemma:

\begin{lemma}\label{lemma:interval}
Mějme libovolnou cestu $C$ v binárním vyhledávacím stromu a vrchol $v$ na této cestě. Pak existují prvky $\ell, r$  univerza, nad kterým je tento binární vyhledávací strom postavený, takové, že každý vrchol $C$ má hloubku vyšší nebo rovnou $v$, právě když pro jeho hodnotu $h$ platí $\ell \leq h \leq r$. Jinými slovy, hodnoty vrcholů pod $v$ tvoří v hodnotách vrcholů v $C$ souvislý interval. Navíc buď za $\ell$ nebo za $r$ můžeme zvolit hodnotu v $v$. Alternativně můžeme požadovat, aby $\ell < h < r$; pak můžeme jako hodnotu $\ell$ nebo $r$ zvolit rodiče $v$.
\end{lemma}

\begin{dukaz}
Z definice binárního vyhledávacího stromu vyplývá, že mezi hodnotami v daném stromu tvoří hodnoty v podstromu libovolného vrcholu souvislý interval. Cesta $C$ je speciální případ binárního vyhledávacího stromu a $v$ je její vrchol. Vrcholy pod s hloubkou rovnou či vyšší $v$ jsou v $C$ právě podstrom $v$. Dále musí souvislý interval tvořit i podstrom rodiče $v$ 
\end{dukaz}

Nyní již můžeme přistoupit k popisu průběhu operace \ope{Find} v tango stromu.
Hledání zahájíme stejně jako v normálním binárním vyhledávacím stromě. Pokaždé,
když ale najdeme vrchol $v$, který je kořenem svého pomocného stromu (krom
kořene celého tango stromu), znamená to, že jsme sešli z preferované cesty ve
stromě $P$. Musíme tedy změnit preferovaný směr příslušného vrcholu v $P$, a
tedy přestavět příslušné pomocné stromy. Zde popíšeme (jak slovně, tak obrázkem \ref{obr:cut_tango}), jak odpojit část původní
preferované cesty z pomocného stromu, připojování nové preferované cesty bude
probíhat podobně.

Mějme tedy pomocný strom $A$ a vrchol $v$ mimo něj, jehož podstrom budeme později chtít do $A$ připojit. Z $v$ přečteme jeho hloubku $d$ v $P$. Pomocí maximálních hloubek v podstromech a pozorování z lemmatu \ref{lemma:interval} najdeme mezi odstraňovanými vrcholy vrchol $r$ s maximální a vrchol $\ell$ s minimální hodnotou. Například minimum budeme hledat následujícím způsobem:

\begin{enumerate}
\item Začneme v kořeni aktuálního $A$.
\item Pokud maximální hloubka v podstromu levého syna je větší nebo rovna $d$, přejdeme do levého syna a opakujeme tento bod.
\item Pokud minimální hloubka v podstromu pravého syna je menší než $d$, přejdeme do pravého syna a vrátíme se na předchozí bod.
\item Vrátíme aktuální vrchol.
\end{enumerate}

\begin{figure}[h!]

  \centering
  \includegraphics[width=.9\linewidth]{../img/cut_tango}
\caption{Rozdělení pomocných stromů} 

\label{obr:cut_tango} 
 
\end{figure}


Přitom vrcholy označené jako kořeny pomocných stromů považujeme za externí.
Dále najdeme předchůdce $\ell'$ vrcholu $\ell$ a následníka $r'$ vrcholu $r$. Poté zavoláme
$\ope{Split}(A, \ell')$ a dostaneme strom $B$ s hodnotami menšími než $\ell'$,
samostatný vrchol $\ell'$ a strom $C$ s hodnotami většími než $\ell'$. Poté
zavoláme $\ope{Split}(C,r')$ a dostaneme $D$, $r'$ a $E$. Nyní označíme kořen
$D$ jako kořen pomocného stromu a připojíme ho jako levého syna vrcholu $r'$.
Dále zavoláme $\ope{Join}(\emptyset, r' E)$ a dostaneme opět strom $C$, ač
uspořádaný jinak než původně. Nakonec zavoláme $\ope{Join}(B,\ell',C)$ a
dostaneme strom $A$ s provedenými požadovanými úpravami. V celé operaci jsme
dvakrát hledali, dvakrát provedli \ope{Join}, dvakrát \ope{Split} a po jednom
použití následníka a předchůdce, tedy provedli jsme $\o(1)$ operací, které
trvají $\o(\log |A|)\subseteq \o(\log\log n)$, celé rozdělení tedy trvalo
$\o(\log\log(n))$.


\section{Multisplay stromy}

\citet{multisplay} představili multisplay strom -- datovou strukturu, která se
snaží spojit dobré vlastnosti splay stromů a tango stromů. Tato struktura je
stále $(\log\log n$)-kompetitivní, ale na rozdíl od tango stromu dosahuje
amortizovaně $\o(\log n)$ na přístup (s worst-case $\Theta(\log^2 n)$ na
přístup). Také dokáže vykonat průchod všemi prvky v jejich pořadí v čase
$\Theta(n)$ (na což tango strom potřebuje $\Theta(n\log\log n)$). Také bude na rozdíl
od tango stromu podporovat operace \ope{Insert} a \ope{Delete}\footnote{Úpravu modelu,
kterou potřebujeme k tomu, abychom mohli mluvit o optimalitě a kompetitivitě
struktury, která podporuje tyto operace, popíšeme později.}.

Myšlenka multisplay stromu je podobná, jako myšlenka tango stromu, pouze jako
pomocné stromy nepoužívá červenočerné stromy, ale splay stromy. Vzhledem k
tomu, že jediné operace červenočerných stromů, které tango strom využívá, jsou
\ope{Split} a \ope{Join}, lze v tango stromech nahradit červenočerné stromy
splay stromy přímočaře, protože splay stromy tyto operace také implementují.
Samotný postup vyhledání se od tango stromu nepatrně liší. Při vyhledání
hodnoty v multisplay stromu nejprve najdeme odpovídající vrchol $v$ bez
jakýchkoli úprav struktury stromu, a až při cestě zpět do kořene postupně
odspoda nahoru měníme preferované směry vrcholů. Po změně všech preferovaných
směrů nakonec ještě změníme preferovaný směr vrcholu $v$.

Samotné měnění preferovaných směrů je o poznání jednodušší než v tango stromu.
Mějme vrchol $v$ ve stromě $T$, kterému chceme změnit preferovaný směr bez újmy
na obecnost zleva doprava. Potom nám stačí nejprve zavolat \ope{Splay$(v)$}.
Potom v levém podstromu $v$ najít pomocí informace o minimální hloubce v
podstromu daného vrcholu vrchol $\ell$, který je vrcholem s nejvyšší hodnotou v
tomto stromě s hloubkou menší než $v$, a zavolat \ope{Splay$(\ell)$} na levý
podstrom $v$ (tedy tak, aby $v$ zůstal kořenem pomocného podstromu a $\ell$ se
stal jeho levým synem). Dále v rámci pravého podstromu $v$ zavoláme \ope{Splay}
na následníka $v$. Tím se část stromu, kterou chceme z pomocného stromu
odstranit, stala pravým podstromem levého syna kořene, a pomocný strom, který
chceme nově připojit, se stal levým podstromem pravého syna kořene. Stačí tedy
upravit příznak kořene pomocného stromu v kořenech těchto podstromů a máme
hotovo. Rozmyslíme si, že dokonce ani není potřeba upravovat hodnoty minimální
hloubky vrcholu v podstromu kořene či jeho synů (kvůli změně příznaků; samy
předchozí operace \ope{Splay} mohou vést k nutnosti úpravy pomocných dat).
Maximální hloubky by sice mohlo být potřeba upravit, ale ty pro algoritmus
multisplay stromu vůbec nepotřebujeme -- nebudeme je tedy ve vrcholech
udržovat.

Nyní představíme úpravy struktury, které je potřeba udělat, aby bylo možné do
struktury vkládat prvky.  Pokud do multisplay stromu $T$ vložíme prvek $p$, je
nutné ho vložit i do stromu $P$. Pokud v binárním vyhledávacím stromě vyhledáme
prvek, který v něm není, projdeme po cestě obsahující oba jeho sousedy, přičemž
jednomu z nich bude chybět na příslušné straně syn. To znamená, že do
multisplay stromu můžeme vložit prvek tak, že použijeme standardní algoritmus
pro vkládání do binárního vyhledávacího stromu. Vkládaný prvek nejprve označíme
za kořen (jeho vlastního jednoprvkového) pomocného stromu. Při vkládání jsme prošli
jak jeho předchůdce, tak následníka. Na hlubším z nich musí ale vrchol $v$ s
hodnotou $p$ viset i ve stromě $P$. Vrchol $v$ má tedy v $P$ hloubku o jedna vyšší,
než hlubší z těchto dvou vrcholů. Minimální hloubky v podstromech se tím
žádnému vrcholu (krom $v$) nezměnily, není je tedy potřeba opravovat. Nakonec
ve stromě popřepínáme preferované syny stejně jako při operaci \ope{Find}.

Tento postup má však jednu vadu -- časové odhady výše všechny závisí na tom, že
$P$ má hloubku $\Theta(\log n)$. Protože o $P$ jsme doteď mluvili jako o
nevyvažovaném stromu, mohli bychom tuto vlastnost operací \ope{Insert} rozbít.
Proto je potřeba z $P$ udělat vyvažovaný strom. Konkrétně zvolíme červenočerný
strom, protože se nám bude hodit, že má amortizovaně $\o(1)$ změn barev a
worst-case $\o(1)$ rotací na operaci. V každém vrcholu si budeme nově pamatovat
jeho barvu v $P$ a hodnoty\footnote{Bylo by lepší, kdybychom si mohli pamatovat
přímo ukazatele na příslušné vrcholy v $T$ (byť amortizovaná i worst-case složitost zůstane zachována). Tím bychom ale
porušili pravidla modelu, která povolují v každém vrcholu pouze dva ukazatele,
a to na syny daného vrcholu.} jeho rodiče a synů v $P$. 

Nyní potřebujeme umět v $T$ provádět úpravy nutné při vyvažování $P$. To
znamená, že musíme umět v $T$ najít potomka a rodiče vrcholu v $P$ a provádět
rotaci hran. Hledání rodiče a potomka vrcholu je snadné -- rozmyslíme si, že
cesta mezi libovolným vrcholem a jeho libovolným potomkem vždy navštíví nejvýše
dva různé pomocné stromy. Protože známe hodnotu uloženou v hledaném rodiči či
potomkovi, najdeme ho vždy pomocí nejvýše dvou operací \ope{Find} v pomocných
stromech. Jedno nalezení potomka či následníka tedy trvá amortizovaně
$\o(\log\log n)$ (včetně změny preferovaného vrcholu, pokud příslušná cesta
vedla napříč dvěma pomocnými stromy).

Při rotaci nás čeká několik problémů. První z nich je, že musíme zachovat
invariant, že každý vrchol má právě jeden preferovaný směr. To vyřešíme změnou
preferovaných směrů. Pokud chceme například provést rotaci hrany ve vrcholu
$v$, který je v $P$ pravým synem vrcholu $w$, musíme nastavit preferovaný směr
vrcholu $v$ doleva a preferovaný směr vrcholu $w$ doprava. Tím dosáhneme toho,
že se při rotaci nezmění, které vrcholy náleží které preferované cestě, pouze
se může změnit jejich pořadí na ní.

Další změny struktury $P$ už se projeví pouze změnami pomocných informací v
$T$, nikoli však změnou struktury. Tím nemáme na mysli, že bychom neprováděli
žádné rotace hran, protože nás ještě čeká několik vyhledání, během nich
provádíme v pomocných stromech standardně operace \ope{Splay}. Již se nezmění
rozložení vrcholů mezi pomocnými stromy.

Samu rotaci pak provedeme úpravou hodnot rodičů a dětí v dotčených vrcholech
(konkrétně je potřeba opravit vrchol, v němž provádíme rotaci, jeho rodiče,
prarodiče a jednoho z potomků). Dále ve vrcholech na koncích rotované hrany
jednoduše opravíme jejich hloubku. Problém je ale v tom, že nyní bychom
potřebovali opravit hloubku ve velké části stromu (například v příkladu výše
zvýšit hloubku v celém podstromu levého syna $\ell$ vrcholu $w$ a snížit v
podstromu pravého syna $p$ vrcholu $v$). Všimneme si ale, že vzhledem k
nastavení preferovaných směrů ve vrcholech $v$ a $w$ tvoří podstrom vrcholu
$\ell$ v $P$ tytéž vrcholy jako podstrom kořene $r$ pomocného stromu
obsahujícího $\ell$ v $T$. Podobně podstrom vrcholu $p$ v $P$ je podstromem
kořene nějakého pomocného stromu v $T$. Tyto kořeny najdeme tak, že budeme z
kořene pomocného stromu obsahujícího $v$ a $w$ postupně hledat hodnoty
vrcholů $p$ a $\ell$, ale vždy vrátíme první vrchol s příznakem kořene, který
najdeme (krom vrcholu, z nějž hledat začínáme).

Nyní nahlédneme, že již umíme změny hloubek vyřešit v konstantním čase pomocí nějaké
z běžných technik, jako například líná propagace změn směrem dolů, nebo, jak si
vybrali autoři multisplay stromu, diferenčním kódováním hloubky. To znamená, že
pouze kořen celého multisplay stromu zná svou hloubku. Ostatní vrcholy znají
rozdíl své hloubky v $P$ a hloubky v $P$ svého rodiče v $T$. Stejným trikem
vyřešíme informaci o minimální hloubce v podstromu -- všimneme si, že v
pomocném stromu obsahujícím $v$ a $w$ změnily hloubku pouze tyto dva vrcholy.
Proto stačí informaci přepočítat v týchž vrcholech, jako v případě hloubky, a
dále na cestě mezi $v$ a $w$.

Protože jsme popsali obecně, jak vykonat změnu barvy vrcholu a rotaci hrany ve stromě, máme i vše pro implementaci operace \ope{Delete} nad multisplay stromy\footnote{Pokud se chceme co nejpřesněji držet modelu, který jsme zavedli, přesouvání hodnot při mazání vnitřních vrcholů tak, jak je v binárním vyhledávacím stromu obvyklé, není možné. Proto musíme \ope{Delete} vrcholu, který má nějaké potomky, implementovat tak, že nejprve provedeme rotace tak, aby se tento vrchol stal listem, až potom ho smažeme.}. Nyní bychom rádi řekli, že i tyto úpravy jsou staticky optimální. To je ale problematické -- náš model nepočítal s vkládáním a mazáním. Proto ho musíme nadefinovat znovu.

Nyní již tedy přístupová posloupnost $S$ není pouze posloupností prvků
univerza, ale posloupností operací $\ope{Find}(x)$, $\ope{Delete}(x)$ a
$\ope{Insert}(x)$, kde $x$ musí náležet univerzu. Modelu nově dovolíme dvě
nové operace, a to vložení listu na místo chybějícího syna aktuálního vrcholu,
a odstranění listu (a označení jeho rodiče za aktuální vrchol). Po každém
stromě budeme vyžadovat, aby se při vykonávání operace \ope{Find} dotkl daného
vrcholu. Dále aby při operaci \ope{Insert} navštívil (v tomto pořadí, byť na
asymptotické chování tento požadavek nebude mít vliv) vrcholy obsahující
předchůdce a následníka vkládaného prvku a nakonec skutečně vytvořil list s
příslušnou hodnotou. Tento požadavek je adekvátní, protože každý binární
vyhledávací strom musí oběma těmito prvky projít při vkládání. Nakonec budeme
požadovat, aby strom při operaci \ope{Delete} navštívil předchůdce mazaného
vrcholu, mazaný vrchol a nakonec následníka mazaného vrcholu. Vzhledem k tomu,
že mazat umíme pouze listy, musíme vždy odstraňovaný vrchol rotacemi přesunout
do listu, což opět znamená, že stejně musíme předchůdce i následníka navštívit.
Tento model je již dobře nadefinovaný, proto v něm dává smysl nadefinovat optimální strom stejně, jako v modelu předchozím.
Pro tento model \citet{multisplay} dokázali následující větu:

\begin{veta}[Dynamic Interelave Bound]
\def\dib{\operatorname{DIB}}
Mějme referenční strom $P$. V tomto stromě má každý vrchol svůj preferovaný
směr, buď doprava nebo doleva. Vždy, když z vrcholu při vyhledání prvku vyrazíme
jiným než preferovaným směrem, změníme preferovaný směr tohoto vrcholu. Strom
$P$ také podporuje rotace hran a operace \ope{Delete} a \ope{Insert} (které
probíhá standardním algoritmem binárního vyhledávacího stromu\footnote{Platí,
že standardní algoritmus na mazání nezapadá do nadefinovaného modelu. To
znamená, že celý náš referenční strom nebude zapadat do modelu dynamického
binárního vyhledávacího stromu. To nevadí, strom $P$ je pouze pomyslný a strom
$T$, který skutečně stavíme, jeho chování pouze simuluje.}). Nechť $\dib(S)_P$ je
počet změn preferovaných směrů všech vrcholů v $P$ při vykonávání posloupnosti
operací $S$, přičemž mezi některými operacemi mohly proběhnout rotace některých
hran. Potom $$\opt(S) \in \Omega(\dib_P(S)/2 - n - 2k + cm),$$ kde $P$ je pomocný strom včetně popisu rotací, které provádíme mezi přístupy a změn díky vkládání a mazání, $n$ je počet vrcholů $P$ po poslední operaci, $k$ je počet rotací hran v popisu $P$, $c$ je vhodně zvolená kladná konstanta a $m$ je délka posloupnosti $S$. 
\end{veta}

Nahlédneme, že vzhledem k výše uvedenému popisu mazání a vkládání je multisplay strom i v dynamickém modelu stále $\log\log(n)$-kompetitivní. 

\section{Geometrický náhled na stromové operace}
