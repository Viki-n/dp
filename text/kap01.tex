\chapter{Teoretický úvod}

V této kapitole zavedeme formální definici binárního vyhledávacího stromu a
pojednáme o jeho výhodách oproti jiným způsobům uložení dat. Dále přiblížíme
(staticky) optimální strom. Pro dynamické stromy připomeneme některé běžné
vyvažovací strategie a také představíme jiné, novější přístupy například třídu
rankově vyvážených stromů a jejich speciální případ Weak AVL strom. Potom
představíme několik mezí optimality, vlastností, které musí mít optimální
binární vyhledávací strom. Nakonec se podíváme na Tango stromy a Multisplay
stromy a dokážeme, že tyto meze splňují (nebo, v případě tango stromu, že je
téměř splňují).

\section{Binární vyhledávací strom}
\def\U\{\mathcal U}
\def\o\{\mathcal O}

Častým úkolem datové struktury je udržovat informaci o množině prvků. Formálně mějme univerzum\footnote{Ve skutečnosti často stačí jakákoli množina $\mathcal U$, pro některé aplikace jakákoli uspořádaná množina $\mathcal U$.} $\mathcal U \subseteq \mathbb N$ a jeho podmonožinu $M$, a budeme chtít datovou strukturu, která nám bude umět o každé prvku $\mathcal U$ říct, jestli náleží množině $M$. Po takových strukturách často chceme nějaké z následujících operací:
\begin{itemize}
\item pro prvek $x \in \U$ rozhodnout, zda $x\in M$,
\item přidat prvek $x \in \U$ do množiny $M$,
\item odstranit prvek $x\in M$ z $M$,
\item vyjmenovat všechny prvky $M$,
\item pro daný prvek $x\in \U \setminus M$ najít nejbližší větší případně menší prvek $M$,
\item pro daný prvek $x\in M$ najít předchůdce, případně následovníka,
\item pro dané dva prvky $x,y\in\U$ takové, že $x<y$, vyjmenovat všechny prvky $z\in M$ takové, že $x \leq z \leq y$.
\end{itemize}

Volba struktury v každém konkrétním případě závisí na tom, které z těchto operací potřebujeme v naší konkrétní aplikaci podporovat. Pokud nám například stačí umět prvky vyjmenovat, postačí nám obyčejné pole. Pokud chceme umět vyhledávat, přidávat i mazat v konstantním čase, je nejlepší volbou nějaká varianta hashovací tabulky. Zejména poslední tři zmíněné operace ale hashovací tabulka umí pouze v čase $\Theta(|M|)$. Pokud tedy tento typ dotazů potřebujeme struktuře pokládat, můžeme využít nějakou ze stromových datových struktur, které v této práci popíšeme.

\begin{definice}
Mějme datovou strukturu, která se skládá z vrcholů. Každý vrchol může mít až
dva následníky, kterým budeme říkat \emph{levý} a \emph{pravý syn}. Jeden
vrchol nazveme \emph{kořen}. Všechny ostatní vrcholy pak budou mít právě
jednoho \emph{rodiče} (tak, že pokud vrchol $u$ je rodičem vrcholu $v$, pak
vrchol $v$ je pravým nebo levý synem vrcholu $u$)\footnote{V některých implementacích si vrcholy nemusí pamatovat ukazatele na své rodiče, my budeme však prozatím předpokládat, že si je pamatují.}. Pro vrchol $v$ nazveme
\emph{podstrom vrcholu $v$} množinu vrcholů, do nichž se dá dostat z z vrcholu
$v$ libovolnou\footnote{Posloupnost může být i prázdná.} posloupností operací \uv{přejdi do
pravého syna} a \uv{přejdi do levého syna}.

V každém vrcholu bude pak právě jedna hodnota, a navíc bude pro vrchol $v$ platit, že hodnoty ve všech vrcholech v podstromu levého syna $v$ jsou ostře menší než hodnota ve $v$, a hodnoty v podstromu pravého syna naopak ostře větší.

Nakonec si zapamatujeme ukazatel na kořen tak, abychom ho kdykoli v konstantním čase nalezli.

Této datové struktuře budeme říkat \emph{Binární vyhledávací strom}
\end{definice}

Při práci se stromem budeme předpokládat, že následující operace umíme v konstantním čase:
\begin{itemize}
\item Nalezni kořen,
\item přejdi do pravého, případně levého syna aktuálního vrcholu,
\item přejdi do rodiče aktuálního vrcholu,
\item přečti či zapiš hodnotu v aktuálním vrcholu,
\item Pokud aktuální vrchol nemá pravého či levého syna, vytvoř na jeho místě nový vrchol s danou hodnotou.
\end{itemize}
Vyhledávání hodnoty $x$ ve stromu pak můžeme provést podle následujícího algoritmu:
\begin{enumerate}
\item Nalezni kořen,
\item podívej se, zda je hodnota $x$ rovna hodnotě v aktuálním vrcholu, a pokud ano, nahlaš nález,
\item je-li hodnota $x$ větší než hodnota v aktuálním vrcholu, podívej se, zda existuje pravý syn aktuálního vrcholu. Pokud ano, přejdi do něj a vrať se ke 2. kroku algoritmu, jinak ohlaš, že  $x$ ve stromu není.
\item je-li hodnota $x$ menší než hodnota v aktuálním vrcholu, podívej se, zda existuje levý syn aktuálního vrcholu. Pokud ano, přejdi do něj a vrať se ke 2. kroku algoritmu, jinak ohlaš, že  $x$ ve stromu není.
\end{enumerate}

Podobným algoritmem budeme prvky přidávat, pouze místo nahlášení neexistence na místě chybějícího syna založíme nový vrchol. Mazání prvkku provedeme následovně:
\begin{itemize}
\item Je-li mazaný prvek list, prostě ho smažeme,
\item má-li mazaný prvek právě jednoho syna, prvek smažeme a jeho syna připojíme pod rodiče mazaného prvku na na místo mazaného prvku,
\item má-li mazaný prvek dva syny, najdeme ve stromě prvek nejblíže větší, jeho
hodnotu zapíšeme na místo odstraňovaného prvku a odstraníme tento nejblíže větší
prvek, kterému nutně chybí přinejmenším levý syn (kdyby existoval, hodnota v
něm by byla menší než hodnota jeho rodiče, ale větší než hodnota odstraňovaného
vrcholu -- tedy jeho rodič by nemohl být nejblíže větší).  
\end{itemize} 

\section{vyvažované stromy}

Tady budou AVL, RB a WAVL stromy.


\section{Výpočetní model}
Chceme-li mluvit o optimálním stromu, musíme nejprve specifikovat, co přesně
budeme za binární vyhledávací strom považovat. Definici, kterou zde
představíme, používali implicitně už \citet{splay}, formalizoval ji však až
\citet{tango}.



\begin{definice}
Mějme statické \emph{univerzum} klíčů $\mathcal U = \{1,2,\dots,n\}$. Dále
mějme binární strom nad těmito klíči takový, že pro každé dva vrcholy $v_1$,
$v_2$ platí, že je-li vrchol $v_1$ v podstromu vrcholu $v_2$, pak je v jeho
levém podstromu, právě když je jeho klíč menší než líč vrcholu $v_2$. Nakonec
mějme \emph{přístupovou posloupnost} $x_1,x_2,\dots,x_m$, kde $\forall i \in
\mathbb N, i\leq m$ platí $x_i\in \mathcal U$. Pak \emph{přístupový algoritmus
binárního vyhledávacího stromu} je algoritmus, který postupně provede přístupy
ke vrcholům s klíči $x_1, x_2,\dots,x_m$.

Přístup probíhá tak, že algoritmus smí mít vždy právě jeden ukazatel na vrchol
stromu, který na počátku každého přístupu ukazuje na kořen stromu. Dále v
každém kroku smí provést právě jednu z následujících operací: 
\begin{itemize}
\item Přesunout ukazatel na levého syna aktuálního vrcholu,
\item přesunout ukazatel na pravého syna aktuálního vrcholu,
\item přesunout ukazatel na rodiče aktuálního vrcholu,
\item provést rotaci hrany mezi aktuálním vrcholem a jeho rodičem.
\end{itemize}

Řekneme, že čas běhu algoritmu je počet těchto operací, které za sekvenci
přístupů provede, plus jedna. O vrcholu stromu řekneme, že jsme se ho při daném
přístupu \emph{dotkli}, pokud na něj někdy během tohoto přístupu ukazoval
ukazatel algoritmu.  \end{definice}

Takovému přístupovému algoritmu se někdy také říká \emph{offline přístupový
algoritmus}. V praxi ale potřebujeme přístupy provádět online.

\begin{definice}
\emph{Online přístupový algoritmus} je tekový přístupový algoritmus, jehož
rozhodnutí během $i$-tého přístupu nijak neovlivňují hodnoty $x_j$ z přístupové
posloupnosti pro $j>i$. Na druhou stranu si tento algoritmus smí v každém
vrcholu uložit až $\mathcal O(1)$ slov paměti informací (nikoli však ukazatele
na vrcholy).  
\end{definice}

Všimneme si, že běžné algoritmy binárních vyhledávacích stromů tuto definici
splňují -- Například červenočerné a AVL stromy potřebují v každém vrcholu
jediný bit informace, splay strom se obejde zcela bez dalších informací.

Pro danou přístupovou sekvenci $X$ existuje přístupový algoritmus, který ji
vykoná optimálně, tedy v nejkratším čase ze všech možných algoritmů. Tento
počet operací označíme $\opt(X)$. Zde předpokládáme, že je strom na začátku v
nejlepší možné konfiguraci. Tím však nesnížíme potřebný čas na přístupy o více
než aditivní $\mathcal O(n)$, protože z libovolného BVS je možné pomocí
$\mathcal O(n)$ rotací vytvořit libovolný jiný (nad tou samou množinou klíčů).
Proto budeme dále zkoumat pouze přístupové posloupnosti $X$ takové, že $|X| \in
\Omega(n)$. Vzhledem k tomu, že nahlédneme, že $\opt(x)\geq |X|$, je tento
faktor asymptoticky zandebatelný. 


\begin{definice}
O přístupovém algoritmu řekneme, že je \emph{$f(n)$-kompetitivní}, pokud každou
posloupnost přístupů $X$ nad univerzem velikosti $n$ vykoná v čase $\mathcal
f(n)\cdot\opt(X)$. O online přístupovém algoritmu řekneme, že je
\emph{dynamicky optimální}, pokud je $\mathcal O(1)$-kompetitivní.
\end{definice}

Předtím, než si popíšeme některé konkrétní stromy, už pouze podotkneme, že
existence dynamicky optimálního algoritmu je otevřeným problémem. Na druhou
stranu například o splay stromech vyslovili \citet{splay} hypotézu, že jsou
dynamicky optimální.

\section{Rankově vyvážené stromy}

\section{Meze optimality}

\section{Tango stromy}

\section{Multisplay stromy}
